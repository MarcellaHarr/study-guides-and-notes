% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother

\ifLuaTeX
  \usepackage{luacolor}
  \usepackage[soul]{lua-ul}
\else
  \usepackage{soul}
\fi




\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={My Study Notes \& Guides},
  pdfauthor={Marcella Harris},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{My Study Notes \& Guides}
\author{Marcella Harris}
\date{2025-07-22}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter*{Welcome}\label{welcome}
\addcontentsline{toc}{chapter}{Welcome}

\markboth{Welcome}{Welcome}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/200.pdf}}

}

\caption{Banner or Logo}

\end{figure}%

This Quarto book contains notes and study guides I've created for my
\textbf{Western Governors University} courses.

Here I've structured all the \textbf{notes}, \textbf{videos}, and
\textbf{study guides} to be easily browsed and reviewed, whether you're
prepping for an exam or refreshing key concepts.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{‚úçÔ∏è What's Inside}\label{whats-inside}
\addcontentsline{toc}{section}{‚úçÔ∏è What's Inside}

\markright{‚úçÔ∏è What's Inside}

\begin{itemize}
\tightlist
\item
  üìö Organized course notes and study guides
\item
  üé• Embedded videos and media
\item
  üß† Quick-reference guides
\item
  üß™ Code examples and exercises
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{üöÄ Getting Started}\label{getting-started}
\addcontentsline{toc}{section}{üöÄ Getting Started}

\markright{üöÄ Getting Started}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-tip-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-tip-color}{\faLightbulb}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

Start exploring by selecting a course or topic from the sidebar.

Or jump straight into this course here:

\end{minipage}%
\end{tcolorbox}

\href{courseD421.qmd}{Begin Here ¬ª}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{üôå Contribute or Feedback}\label{contribute-or-feedback}
\addcontentsline{toc}{section}{üôå Contribute or Feedback}

\markright{üôå Contribute or Feedback}

This project is personal, but feedback is welcome!\\
Feel free to open an issue or follow my GitHub:

\href{https://github.com/MarcellaHarr/study-guides-and-notes}{GitHub
Repository}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\bookmarksetup{startatroot}

\chapter*{Discrete Math II}\label{discrete-math-ii}
\addcontentsline{toc}{chapter}{Discrete Math II}

\markboth{Discrete Math II}{Discrete Math II}

Discrete Math II Functions and Applications (D421)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, colframe=quarto-callout-note-color-frame, opacitybacktitle=0.6, colback=white, opacityback=0, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, leftrule=.75mm, toprule=.15mm, coltitle=black, bottomtitle=1mm, titlerule=0mm, breakable, bottomrule=.15mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, left=2mm]

These exercises are not mines. They are from this
\href{https://quizlet.com/explanations/textbook-solutions/discrete-mathematics-and-its-applications-8th-edition-9781259676512}{Quizlet
¬ª}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Module I: Working with Sets}\label{module-i-working-with-sets}
\addcontentsline{toc}{section}{Module I: Working with Sets}

\markright{Module I: Working with Sets}

\subsubsection*{Section 1:}\label{section-1}
\addcontentsline{toc}{subsubsection}{Section 1:}

\subsubsection*{1.2}\label{section}
\addcontentsline{toc}{subsubsection}{1.2}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set theory}\label{set-theory}
\addcontentsline{toc}{paragraph}{set theory}

\url{https://youtu.be/uRj87VpsOkM}

A {\textbf{set}} is a collection of objects. The objects in a set are
called {\textbf{elements}}. The {\textbf{roster notation}} definition of
a set is a list of the elements enclosed in curly braces with the
individual elements separated by commas.

\subsubsection*{1.2.1}\label{section-2}
\addcontentsline{toc}{subsubsection}{1.2.1}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{empty set}\label{empty-set}
\addcontentsline{toc}{paragraph}{empty set}

\url{https://youtu.be/nXAOZo_gMaQ}

The set with no elements is called the {\textbf{empty set}} and is
denoted by the symbol \(‚àÖ\). The empty set is sometimes referred to as
the {\textbf{null set}} and can also be denoted by \(\{ \}\). {It is
also an element of every power set.} A {\textbf{finite set}} has a
finite number of elements. An {\textbf{infinite set}} has an infinite
number of elements.

\subsubsection*{1.2.2}\label{section-3}
\addcontentsline{toc}{subsubsection}{1.2.2}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set member \& subset}\label{set-member-subset}
\addcontentsline{toc}{paragraph}{set member \& subset}

\url{https://youtu.be/jsZGvxxnL_c}

\section{``Element of'' Example}

\textbf{element} \(\epsilon\) \textbf{set}

\(x\enspace \epsilon \enspace \{w,x\}\)

\(p\enspace \epsilon \enspace \{q,r,s\}\)

\section{Subset Example}

\textbf{set} \(\subseteq\) \textbf{set}

\(\{6,7,8\}\enspace \subseteq \enspace \{1,2,3,...\}\)

\(\{2\}\enspace \subseteq \enspace \{1,2\}\)

The {\textbf{cardinality}} of a finite set is the number of elements in
that set, and is denoted as \(|\thinspace|\). Two sets are equal if they
have exactly the same elements.

\subsubsection*{1.2.3}\label{section-4}
\addcontentsline{toc}{subsubsection}{1.2.3}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{theory symbols}\label{theory-symbols}
\addcontentsline{toc}{paragraph}{theory symbols}

\url{https://youtu.be/UqulNbiHrrU}

\begin{table}

\caption{\label{tbl-panel}Math Symbol Examples }

\begin{minipage}{\linewidth}

\subcaption{\label{tbl-first}Common Math Sets}

\centering{

\begin{tabular}{lll}
\toprule
Symbol & Set & Example\\
\midrule
\(\mathbb{N}\) & The set of natural numbers: All integers greater than
or equal to 0. & \(0, 1, 2\)\\
\(\mathbb{Z}\) & The set of all
integers. & \(..., -2, -1, 0, 1, 2, ...\)\\
\(\mathbb{Q}\) & The set of rational numbers: All real numbers that can
be expressed as a/b, where a and b are integers and b ‚â†
0. & \(0,\thinspace 1/2,\thinspace 5.23, \thinspace -5/3\)\\
\(\mathbb{R}\) & The set of real
numbers. & \(0, 1/2, 5.23, -5/3,\thinspace \pi, \sqrt{2}\)\\
\bottomrule
\end{tabular}

}

\end{minipage}%
\newline
\begin{minipage}{\linewidth}

\subcaption{\label{tbl-second}Superscripts}

\centering{

\begin{tabular}{ll}
\toprule
Symbol & Set\\
\midrule
\(\mathbb{R^+}\) & The set of all positive real numbers.\\
\(\mathbb{R^-}\) & The set of all negative real numbers.\\
\(\mathbb{Z^+}\) & The set of all positive integers.\\
\(\mathbb{Z^-}\) & The set of all negative integers\\
\bottomrule
\end{tabular}

}

\end{minipage}%

\end{table}%

A number x is {\textbf{positive}} if \(x > 0\). A number x is
{\textbf{negative}} if \(x < 0\). The number \(0\) is neither positive
nor negative, so \(0 \in \mathbb{Z^+}\) and \(0 \in \mathbb{Z^-}\), and
a number \(x\) is {\textbf{non-negative}} if \(x ‚â• 0\).

\subsubsection*{1.2.4}\label{section-5}
\addcontentsline{toc}{subsubsection}{1.2.4}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set builder}\label{set-builder}
\addcontentsline{toc}{paragraph}{set builder}

\url{https://youtu.be/xnfUZ-NTsCE}

In {\textbf{set builder notation}}, a set is defined by specifying that
the set includes all elements in a larger set that also satisfy certain
conditions.

\(\mathbb{A} = { x \in \mathbb{S} : \mathbb{P}(x) }\)

\emph{\(\mathbb{S}\) is the larger set from which the elements in
\(\mathbb{S}\) are taken.}

\subsubsection*{1.2.5 / 1.3}\label{section-6}
\addcontentsline{toc}{subsubsection}{1.2.5 / 1.3}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{universal set}\label{universal-set}
\addcontentsline{toc}{paragraph}{universal set}

\url{https://youtu.be/GVZUpOm3XUg}

The {\textbf{universal set}} is a set that contains all elements
mentioned in a particular context, and is denoted by the variable
\(\cup\). A {\textbf{Venn diagram}} visual representation of sets using
overlapping circles or other closed curves. However, zyBook's uses
rectangles to denote the universal set and oval shapes to denote sets
within \(\cup\).

\url{https://youtu.be/s8FGAclojcs}

\section{Equal Subsets}

\textbf{set} \(\subseteq\) \textbf{set}

Equal sets \(\{ \}\) can be considered subsets \(\subseteq\). Meaning
all of a set's elements must be found in the other set (superset).

\(\mathbb{A}= \{ \mathbb{a, b, c, d, e} \}\)
\(\mathbb{B}= \{ \mathbb{e, b, c, a, d} \}\)

\(\mathbb{B} \subseteq \mathbb{A}\)

\section{Proper Subsets}

\textbf{set} \(\subset\) \textbf{set}

With {\textbf{proper subsets}} \(\subset\), equality is not possible.
Meaning, a set that is a subset \(\subseteq\) with lesser elements than
the superset is considered a proper subset.

\(\mathbb{A}= \{ \mathbb{a, b, c, d, e} \}\)
\(\mathbb{B}= \{ \mathbb{e, b, c, a, d} \}\)
\(\mathbb{C}= \{ \mathbb{e, c, a} \}\)

\(\mathbb{C} \subset \mathbb{A}\) \textbf{or}
\(\mathbb{C} \subset \mathbb{B}\)

A {\textbf{subset}} is a set whose elements are all contained within
another set. If every element, for example, in set \(\mathbb{A}\) is
also an element of set \(\mathbb{B}\), then \(\mathbb{A}\) is a subset
of \(\mathbb{B}\). It is denoted by the symbol:
\(\mathbb{A} \thinspace \subseteq \mathbb{B}\).

A {\textbf{proper subset}} is a subset that is strictly contained within
another set, meaning it does not include all elements of the larger set.
If \(\mathbb{A} \thinspace \subseteq \mathbb{B}\) and
\(\mathbb{A} \thinspace \ne \thinspace \mathbb{B}\), then \(\mathbb{A}\)
is a proper subset of \(\mathbb{B}\). It is denoted by the symbol:
\(\mathbb{A} \thinspace \subset \thinspace \mathbb{B}\).

\subsubsection*{1.4}\label{section-7}
\addcontentsline{toc}{subsubsection}{1.4}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set containing}\label{set-containing}
\addcontentsline{toc}{paragraph}{set containing}

\url{https://youtu.be/WgE5kr0Tj7M}

The {\textbf{empty set}} \(\varnothing\) is not the same as
\(\{ \varnothing \}\). The cardinality of \(\{ \varnothing \}\) is one
since it contains exactly one element, which is the empty set. A set can
contain a combination of numbers and sets of numbers as in:

\(\mathbb{B} = \{ 2, \varnothing, \{1, 2, 3\}, \{1\} \}\)

\subsubsection*{1.5}\label{section-8}
\addcontentsline{toc}{subsubsection}{1.5}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{power set}\label{power-set}
\addcontentsline{toc}{paragraph}{power set}

\url{https://youtu.be/0XNSBoqG-1s}

A {\textbf{power set}} is a set of all the \ul{subsets}, including the
empty set and the set itself. For example, the power set of a set
\(\mathbb{A}\), denoted \(P\{\mathbb{A}\}\), is the set of all subsets
of \(\mathbb{A}\), so, if \(\mathbb{A} = \{1,2,3\}\), then:

\(P\{\mathbb{A}\} = \{ \varnothing, \{1\}, \{2\}, \{3\}, \{1, 2\}, \{1,3\}, \{2,3\}, \{1, 2, 3\} \}\)

\begin{description}
\tightlist
\item[Cardinality of a power set]
Let \(\mathbb{A}\) be a finite set of cardinality \(n\). Then the
cardinality of the power set of \(\mathbb{A}\) is \(2^n\), or
\(\mid P\{\mathbb{A}\}=2^n \mid\).
\end{description}

\url{https://youtu.be/kPcDNNB3U4g}

\subsubsection*{1.6}\label{section-9}
\addcontentsline{toc}{subsubsection}{1.6}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{intersection \& union}\label{intersection-union}
\addcontentsline{toc}{paragraph}{intersection \& union}

\url{https://youtu.be/mOMoZYGirQQ}

{\textbf{Set intersection}} is the operation that produces a set
containing only the elements that are common to both sets. If \(A\) and
\(B\) are sets, their intersection is the set of all elements that are
members of both \(\mathbb{A}\) {\textbf{and}} \(\mathbb{B}\). It is
denoted by the symbol: \(\mathbb{A} \cap \mathbb{B}\)

\section{Formula}

\(\mathbb{A} \cap \mathbb{B} = \{ x \thinspace \epsilon \thinspace \mathbb{A} \enspace\text{and}\enspace x \thinspace \epsilon \thinspace \mathbb{B} \}\)

This is the formula for the set intersection.

\section{Example}

IF

\(\mathbb{A} = \{ 1,3,5 \}\); \(\mathbb{B} = \{ 3,4,5 \}\);

THEN

\(\mathbb{A} \cap \mathbb{B} = \{ 3,5 \}\);

\section{Note}

The \emph{union} and {\textbf{intersection}} operations are commutative.
That is,

\(\mathbb{A} \cap \mathbb{B} = \mathbb{B} \cap \mathbb{A}\)

\url{https://youtu.be/hJHGyLpa0RQ}

{\textbf{Set union}} is the operation that produces a set containing all
elements that belong to either of two sets. If \(A\) and \(B\) are sets,
their union is the set of all elements that are in \(\mathbb{A}\),
{\textbf{or}} \(\mathbb{B}\), {\textbf{or}} in both. It is denoted by
the symbol: \(\mathbb{A} \cup \mathbb{B}\).

\section{Formula}

\(\mathbb{A} \cup \mathbb{B} = \{ x \thinspace \epsilon \thinspace \mathbb{A} \enspace\text{or}\enspace x \thinspace \epsilon \thinspace \mathbb{B} \}\)

This is the formula for the set union.

\section{Example}

IF

\(\mathbb{A} = \{ 1,3,5 \}\); \(\mathbb{B} = \{ 3,4,5 \}\);

THEN

\(\mathbb{A} \cup \mathbb{B} = \{ 1,3,4,5 \}\);

\section{Note}

The {\textbf{union}} and \emph{intersection} operations are commutative.
That is,

\(\mathbb{A} \cup \mathbb{B} = \mathbb{B} \cup \mathbb{A}\)

\subsubsection*{1.7}\label{section-10}
\addcontentsline{toc}{subsubsection}{1.7}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set operation}\label{set-operation}
\addcontentsline{toc}{paragraph}{set operation}

\url{https://youtu.be/Mhip1rljvRo}

\section{Set Operations}

\(\mathbb{A} \cup \mathbb{B}; \enspace \mathbb{A} \cap \mathbb{B}; \enspace \mathbb{A} \setminus \mathbb{B}\)

\texttt{Set\ operations} are mathematical procedures used to create new
sets from existing ones. Common operations include union, intersection,
and difference, and they follow rules similar to logical operators in
propositional logic.

\section{Set Expression}

A \texttt{set\ expression} is a mathematical statement that combines
sets using one or more operations to define a new set. Parentheses are
often used to clarify order of operations and ensure accurate
interpretation.

An example is: \(\mathbb{A} \cup (\,\mathbb{B} \cap \mathbb{C})\,\),

which represents the union of A with the intersection of B and C.

\section{Set Defined}

A \texttt{defined\ set} is when its elements are explicitly or logically
described. It can be defined by listing elements, using conditions, or
applying set operations.

For example,

\(\mathbb{A} \cap \mathbb{B} \cap \mathbb{C} \cap \mathbb{D}\)

The set above is defined as the set of elements common to all four sets:
\(\mathbb{A}, \mathbb{B}, \mathbb{C}, \text{and} \thinspace \mathbb{D}\).

\subsubsection*{1.7.2}\label{section-11}
\addcontentsline{toc}{subsubsection}{1.7.2}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{integer multiples}\label{integer-multiples}
\addcontentsline{toc}{paragraph}{integer multiples}

\url{https://youtu.be/MbwosaqUkig}

\section{Exercise (a)}

Use the definition for \(A_i\) to answer the questions.For
\(i \in \mathbb{Z^+}, A_i\), is the set of all integer multiples of
\(i\).

\textbf{Describe the following set using set builder notation:}

\[\bigcap^5_{i=1} A_i\]

\section{Step 1}

\textbf{Understand the definition:}

We're told that for each \(i\) in the set of positive integers
(\(\mathbb{Z^+}\)), the set \(A_i\) contains all positive
{\textbf{integer multiples}} of \(i\).

\textbf{Examples:}

\begin{itemize}
\tightlist
\item
  \(A_i\) is the set of all integers (since every number is divisible by
  1)
\end{itemize}

\(A_1 = \{0,1,2,3,4,5,6, \ldots\}\)

\begin{itemize}
\tightlist
\item
  \(A_2\) is the set of all even integers
\end{itemize}

\(A_2 = \{0,2,4,6,8,10, \ldots\}\)

\begin{itemize}
\tightlist
\item
  \(A_3\) is the set of all integers divisible by 3
\end{itemize}

\(A_3 = \{0,3,6,9,12,15, \ldots\}\)

\begin{itemize}
\tightlist
\item
  \(A_4\) is the set of all integers divisible by 4
\end{itemize}

\(A_4 = \{0,4,8,12,16,20, \ldots\}\)

\begin{itemize}
\tightlist
\item
  \(A_5\) is the set of all integers divisible by 5
\end{itemize}

\(A_5 = \{0,5,10,15,20,25, \ldots\}\)

\section{Step 2}

\[
What Does \bigcap_{i=1}^5 A_i Mean?
\]

This is asking:

{\textbf{``What integers are in every one of these sets
\(A_1, A_2, A_3, A_4, A_5\)?''}}

That means we're looking for numbers that are divisible by 1, 2, 3, 4,
and 5. So, we need to find integers that are multiples of all these
numbers at once.

\section{Step 3}

\textbf{Find the Least Common Multiple}

To satisfy all five conditions, a number must be a common multiple of
all five integers and to be a multiple of all five integers, a number
has to be divisible by their \textbf{least common multiple (LCM)}.

\begin{itemize}
\tightlist
\item
  \textbf{LCM(1, 2, 3, 4, 5) = 60}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  A‚ÇÅ      A‚ÇÇ        A‚ÇÉ        A‚ÇÑ        A‚ÇÖ}
\NormalTok{         / \textbackslash{}       / \textbackslash{}       / \textbackslash{}       / \textbackslash{}}
\NormalTok{ none   1   2     1   3     2   2     1   5}
\end{Highlighting}
\end{Shaded}

Then multiply the prime factors, \(2 \cdot 3 \cdot 2 \cdot 5=60\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

So the set contains all integers that are multiples of 60 --- that's the
overlap between all five sets!

\section{Result}

The intersection of the sets \(A_1\) through \(A_5\) in {\textbf{set
builder notation}} is:

\[
\bigcap_{i=1}^5 A_i = \{ x:x=60k,\thinspace \text{for} \thinspace k \in \mathbb{Z^+} \}
\]

{\emph{``The set of all values x such that x equals 60 times k, where k
is any integer.''}}

\section{Exercise (b)}

Use the definition for \(A_i\) to answer the questions.For
\(i \in \mathbb{Z^+}, A_i\), is the set of all integer multiples of
\(i\).

\textbf{Describe the following set using roster notation:}

\[( \,\bigcup^5_{i=2} A_i) \, \cap \{ x \in \mathbb{Z}:1 \leq x \leq 20 \}\]

\section{Step 1}

\textbf{Understand the definition}

\begin{itemize}
\item
  \[
  ( \,\bigcup^5_{i=2} A_i) \, \text{: This means take all multiples of any one of,} A_2, A_3, A_4, A_5 ( \, excluding A_1, ) \, \text{and put them into one big set (union.)}\]
\item
  \(\bigcap\): This means intersection, or common values between two
  sets.
\item
  \(\{ x \in \mathbb{Z}:1 \leq x \leq 20 \}\): This is just the set of
  integers from 1 to 20, and is read as:

  \begin{itemize}
  \tightlist
  \item
    {``The set of all integers x such that x is greater than or equal to
    1 and less than or equal to 20.''}
  \end{itemize}
\end{itemize}

\section{Step 2}

\textbf{List All Multiples of 1 to 5 (up to 20)}

We only care about values up to 20 because of the intersection. So list
all multiples of 2 to 5 from 1 to 20, by asking, ``Is it a multiple of
2, 3, 4, or 5?'':

\begin{itemize}
\item
  \(A_2:\{ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 \}\)
\item
  \(A_3:\{ 3, 6, 9, 12, 15, 18 \}\)
\item
  \(A_4:\{ 4, 8, 12, 16, 20 \}\)
\item
  \(A_5:\{ 5, 10, 15, 20 \}\)
\end{itemize}

\section{Step 3}

\textbf{Union the Sets \(A_1 \cup A_2 \cup A_3 \cup A_4 \cup A_5\)}

Now, combine all the unique elements from all five sets --- but since
\(A_1\) already includes everything from 1 to 20, the union is just:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  2           3           4           5}
\NormalTok{ /|\textbackslash{}         /|\textbackslash{}         /|\textbackslash{}         /|\textbackslash{}}
\NormalTok{2 4 6      3 6 9      4 8 12      5 10 15}
\NormalTok{8 10 12    12 15 18   16 20       20}
\NormalTok{14 16 18                 }
\NormalTok{20}

\NormalTok{Excluded:}
\NormalTok{  1  7  11  13  17  19}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

The common multiples combined together are: \$\{2, 3, 4, 5, 6, 8, 9, 10,
12, 14, 15, 16, 18, 20\}\$

\section{Result}

The union of the sets \(A_2\) through \(A_5\) in {\textbf{roster
notation}} is:

\[
( \,\bigcup^5_{i=2} A_i) \, = \{ 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20 \}
\]

\subsubsection*{1.7.4}\label{section-12}
\addcontentsline{toc}{subsubsection}{1.7.4}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{multiple set}\label{multiple-set}
\addcontentsline{toc}{paragraph}{multiple set}

\url{https://youtu.be/2LutE_XlGP8}

\section{Intersection}

\(\bigcap^n_{i=0} A_i\)

The {\textbf{intersection of multiple sets}} is an operation that yields
the set of all elements common to every set in a sequence. When given a
collection of sets indexed by integers from 1 to n, their intersection
is the set of elements that appear in all of the sets from
{\(A_\imath\)} to {\(A_n\)}.

\section{Union}

\(\bigcup^n_{i=0} A_i\)

The {\textbf{union of multiple sets}} is an operation that yields the
set of all elements that appear in at least one of the sets in a
sequence. When given a collection of sets indexed by integers from 1 to
n, their union includes every element from any of the sets
{\(A_\imath\)} through {\(A_n\)}.

\subsubsection*{1.8}\label{section-13}
\addcontentsline{toc}{subsubsection}{1.8}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set/symmetric difference}\label{setsymmetric-difference}
\addcontentsline{toc}{paragraph}{set/symmetric difference}

\url{https://youtu.be/HJduHa16Y70}

\section{Set Difference}

\(\mathbb{A} - \mathbb{B}\)

{\textbf{Set difference}} is the operation that produces a set
containing elements that belong to one set but {\ul{\textbf{not}}} to
another. If \(\mathbb{A}\) and \(\mathbb{B}\) are sets, the set
difference \(A -B\) contains all elements that are in \(\mathbb{A}\) and
not in \(\mathbb{B}\).

\section{Note}

\url{https://youtu.be/mtRzKu4eGf4}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

The set difference operation is not {\textbf{commutative}}, meaning
\(A - B \neq B - A\) in general.

\url{https://youtu.be/wlehAlkJfA0}

\section{Symmetric Difference}

\(\mathbb{A} \oplus \mathbb{B}\)

{\textbf{Symmetric difference}} is the operation that produces a set
containing elements that belong to exactly one of two sets --- in either
\(\mathbb{A}\) or \(\mathbb{B}\), but \ul{not in both}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

An alternate definition expresses it using union and set difference:

\(\mathbb{A} \oplus \mathbb{B}= ( \, \mathbb{A} - \mathbb{B} ) \, \cup ( \, \mathbb{B} - \mathbb{A} ) \,\)

\section{Note}

The symmetric difference is {\textbf{commutative}}, so
\(\mathbb{A} \oplus \mathbb{B} = \mathbb{B} \oplus \mathbb{A}\)

\subsubsection*{1.8.1}\label{section-14}
\addcontentsline{toc}{subsubsection}{1.8.1}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set subtraction}\label{set-subtraction}
\addcontentsline{toc}{paragraph}{set subtraction}

\url{https://youtu.be/IL465-AUUVY}

\emph{Note: {Set subtraction} is not associative}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Here's a vid on how, specifically, set and symmetric difference
translates into programming.

\url{https://youtu.be/fX51KlbC1TM}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection*{1.8.3}\label{section-15}
\addcontentsline{toc}{subsubsection}{1.8.3}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{set complement operation}\label{set-complement-operation}
\addcontentsline{toc}{paragraph}{set complement operation}

\url{https://youtu.be/HrD_vpFzrBk}

\section{Complement Operations}

The \textbf{set complement operation} produces a set containing all
elements in a universal set \((\, \mathbb{U} )\,\) that are \textbf{not}
in a subset \((\, \mathbb{A} )\,\).

It is denoted by:

\begin{itemize}
\item
  \((\, \mathbb{A}^c )\,\) or \((\, \overline{\mathbb{A}} )\,\)
  \emph{(depending on notation style)}
\item
  Formally:

  \begin{itemize}
  \tightlist
  \item
    \([\, \mathbb{A}^c = \{ x \in \mathbb{U} : x \notin \mathbb{A} \} \quad \text{or} \quad \mathbb{A}^c = \mathbb{U} - \mathbb{A}]\,\)
  \end{itemize}
\end{itemize}

üìò Note: This operation \textbf{requires} a well-defined universal set
\((\, \mathbb{U} )\,\) unlike union or intersection.

\section{Alternate Form}

You can express the complement using a \textbf{set difference}
operation:

\([\, \mathbb{A}^c = \mathbb{U} - \mathbb{A} ]\,\)

This says: take everything in the universe \(( \, \mathbb{U} ) \,\) and
remove the contents of \(( \, \mathbb{A} ) \,\).

\section{Example}

Let the universal set be \(( \, \mathbb{U} = \mathbb{Z} ) \,\) the set
of all integers.

\textbf{Define:}

\([ \, \mathbb{A} = \{ x \in \mathbb{Z} : x \text{ is odd} \} ] \,\)

\textbf{Then:}

\([ \, \mathbb{A}^c = \{ x \in \mathbb{Z} : x \text{ is even} \} ] \,\)

Which is the set of all even integers.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{table}

\caption{\label{tbl-panel}Section 1.8 Summary }

\begin{minipage}{\linewidth}

\subcaption{\label{tbl-first}Set Operations}

\centering{

\begin{tabular}{lll}
\toprule
Operation & Notation & Description\\
\midrule
Intersection & \(\mathbb{A} \cap \mathbb{B}\) & \(\{ x: x \in \mathbb{A} \enspace \text{and} \enspace x \in \mathbb{B} \}\)\\
Union & \(\mathbb{A} \cup \mathbb{B}\) & \(\{ x:x \in \mathbb{A} \quad \text{or} \quad x \in \mathbb{B} \quad \text{or} \enspace \text{both} \}\)\\
Difference & \(\mathbb{A} - \mathbb{B}\) & \(\{ x:x \in \mathbb{A} \quad \text{and} \quad x \notin \mathbb{B} \}\)\\
Symmetric
Difference & \(\mathbb{A} \oplus \mathbb{B}\) & \(\{ x:x \in \mathbb{A}-\mathbb{B} \quad \text{or} \quad x: \in \mathbb{B}-\mathbb{A} \}\)\\
Complement & \(\overline{\rm \mathbb{A}}\) & \(\{ x:x \notin \mathbb{A} \}\)\\
\bottomrule
\end{tabular}

}

\end{minipage}%

\end{table}%

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection*{1.9}\label{section-16}
\addcontentsline{toc}{subsubsection}{1.9}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{combining sets}\label{combining-sets}
\addcontentsline{toc}{paragraph}{combining sets}

\url{https://youtu.be/ZQ5pGz3zAYA}

\url{https://youtu.be/PCEPxKrRaQE}

\section{Definition}

{\textbf{Combining sets}} refers to the use of multiple set operations
--- such as \textbf{union}, \textbf{intersection}, \textbf{difference},
and \textbf{complement} --- in a single expression to create new sets
from existing ones.

These operations may be nested or sequenced to define increasingly
complex relationships among sets, and are governed by mathematical
precedence similar to arithmetic operations.

\section{Explanation}

\begin{itemize}
\item
  The complement operation requires a clearly defined \textbf{universal
  set} \((\, \mathbb{U} )\,\) against which the contents of a subset
  \((\, \mathbb{A} )\,\) are negated.
\item
  Combined operations should be evaluated by grouping parentheses first,
  then applying the logic of each operator.
\item
  Set expressions such as
  \((\, (\, \mathbb{A} \oplus \mathbb{B})\, \cup (\, \mathbb{A} \cap \mathbb{C})\, )\,\)
  illustrate how \textbf{symmetric difference}, \textbf{union}, and
  \textbf{intersection} interact.
\end{itemize}

üß† Tip: Just as in algebra, parentheses determine the order of
evaluation. For example:

\begin{itemize}
\tightlist
\item
  \((\, (\, \mathbb{A} \cup \mathbb{B})\, \cap \mathbb{C} )\,\) may
  produce a different result than
  \((\, \mathbb{A} \cup (\, \mathbb{B} \cap \mathbb{C})\, )\,\)
\end{itemize}

\section{Example}

\textbf{Let:}

\begin{itemize}
\item
  \((\, \mathbb{A} = \{ \text{even integers} \} )\,\)
\item
  \((\, \mathbb{U} = \mathbb{Z} )\,\) the set of all integers
\end{itemize}

\textbf{Then:}

\begin{itemize}
\item
  The complement of \((\, A )\,\) is:

  \begin{itemize}
  \tightlist
  \item
    \([\,A^c = \{ x \in \mathbb{Z} : x \text{ is odd} \}]\,\)
  \end{itemize}
\end{itemize}

\textbf{Now combine operations:}

\begin{itemize}
\item
  \((\, (\, \mathbb{A} \oplus \mathbb{B})\, \cup (\, \mathbb{A} \cap \mathbb{C})\, )\,\)
  defines a new set composed of:

  \begin{itemize}
  \item
    Elements in \(A\) {\textbf{or}} \(B\) but {\textbf{not both}},
    combined with
  \item
    Elements shared between \(A\) {\textbf{and}} \(C\)
  \end{itemize}
\end{itemize}

\paragraph*{Exercises}\label{exercises}
\addcontentsline{toc}{paragraph}{Exercises}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{1a - 1c}\vspace{3mm}

\subparagraph*{Exercise 1a}\label{exercise-1a}
\addcontentsline{toc}{subparagraph}{Exercise 1a}

\section{Step-1}

The goal of this exercise is to list all elements of the set

\(\{x‚à£x \text{ is a real number such that } x^2=1\}\)

\textbf{What is a set?}

\section{Step-2}

A \textbf{set} is an unordered collection of objects that satisfy a
certain property. This property can be expressed mathematically or in a
form of a sentence.

\section{Step-3}

Let's identify all real numbers \(x\) for which \(x^2=1\).

\(x^2 = 1 ‚üπ x = ¬± 1 ‚üπ x = ¬± 1\)

Therefore, elements of the given set are \(‚àí1\) and \(1\). We can also
write this as

\(\{x‚à£x \text{ is a real number such that } x^2=1\} = \{-1, 1\}\).

\section{Step-4}

Let's recap what we have done.

We determined that the real numbers whose square is equal to \(1\) are
\(‚àí1\) and \(1\), and that they are the only elements of this set.

\section{Results}

\(‚àí1,1\)

\subparagraph*{Exercise 1b}\label{exercise-1b}
\addcontentsline{toc}{subparagraph}{Exercise 1b}

\section{Step-1}

The goal of this exercise is to list all elements of the set

\(\{x‚à£ x \text{ is a positive integer less than } 12\}\)

\textbf{What is a set?}

\section{Step-2}

A \textbf{set} is an unordered collection of objects that satisfy a
certain property. This property can be expressed mathematically or in a
form of a sentence.

\section{Step-3}

Remember that positive integers are whole positive numbers, also called
natural numbers. This set consists of numbers \(1,2,3,‚Ä¶.\) Therefore,
integers that are less than \(12\) are

\(1,2,3,4,5,6,7,8,9,10,11\)

These are the elements of our set, which we can also denote as

\(\{x‚à£ x \text{ is a positive integer less than } 12\} = \{1,2,3,4,5,6,7,8,9,10,11\}\)

\section{Step-4}

Let's recap what we have done. We recalled what the set of positive
integers is, and then identified the ones that are less than \(12\).
These are the whole numbers from \(1\) to \(11\), and they are the only
elements of our set.

\section{Results}

\(1,2,3,4,5,6,7,8,9,10,11\)

\subparagraph*{Exercise 1c}\label{exercise-1c}
\addcontentsline{toc}{subparagraph}{Exercise 1c}

\section{Step-1}

The goal of this exercise is to list all elements of the set

\textbf{What is a set?}

\section{Step-2}

A \textbf{set} is an unordered collection of objects that satisfy a
certain property. This property can be expressed mathematically or in a
form of a sentence.

\section{Step-3}

In part \(b)\,\) we recalled that integers are whole numbers. Their
squares are positive whole numbers, or natural numbers. Suppose that a
is an integer such that

\(a^2=x\)

Since \(10^2=100\), and we know that \(x<100\), it follows that

\(a^2 < 10^2 ‚üπ \sqrt{a^2} > \sqrt{10^2} ‚üπ |a| < |10| ‚üπ |a| < 10\)

Therefore, \(a\) is an integer whose absolute value is smaller than
\(10\). The list of possible values of a is

\(0,\thinspace¬±1,\thinspace¬±2,\thinspace¬±3,\thinspace¬±4,\thinspace¬±5,\thinspace¬±6,\thinspace¬±7,\thinspace¬±8,\thinspace¬±9\)

Consequently, the list of all possible values of x, which is the square
of a is

\(0,1,4,9,16,25,36,49,64,81\)

Hence, there are \(10\) elements of our set.

\section{Step-4}

Let's recap what we have done.

First, we identified that the absolute value of an integer whose square
is less than \(100\) is smaller than \(10\). Then, we listed them and
found their squares, which are the elements of our set.

\section{Results}

\(0,1,4,9,16,25,36,49,64,81\)

\end{tcolorbox}

\subsubsection*{Section 2:}\label{section-2-1}
\addcontentsline{toc}{subsubsection}{Section 2:}

\bookmarksetup{startatroot}

\chapter*{Data Structures \& Algorithms
I}\label{data-structures-algorithms-i}
\addcontentsline{toc}{chapter}{Data Structures \& Algorithms I}

\markboth{Data Structures \& Algorithms I}{Data Structures \& Algorithms
I}

Data Structures and Algorithms I (C949)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, colframe=quarto-callout-note-color-frame, opacitybacktitle=0.6, colback=white, opacityback=0, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, leftrule=.75mm, toprule=.15mm, coltitle=black, bottomtitle=1mm, titlerule=0mm, breakable, bottomrule=.15mm, rightrule=.15mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, left=2mm]

This study guide is not mines. It belongs to this person
\href{https://www.reddit.com/r/WGU/comments/1f52ld1/great_proctor_experience_c949_data_structures_and/}{OfficeRunner
\textgreater\textgreater{}} I found on reddit.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Explains Algorithms (29\%)}\label{explains-algorithms-29}
\addcontentsline{toc}{section}{Explains Algorithms (29\%)}

\markright{Explains Algorithms (29\%)}

\subsubsection*{Characteristics of
Algorithms}\label{characteristics-of-algorithms}
\addcontentsline{toc}{subsubsection}{Characteristics of Algorithms}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Names}\vspace{3mm}

\textbf{Finiteness}

An algorithm must always have a finite number of steps before it ends.
When the operation is finished, it must have a defined endpoint or
output and not enter an endless loop.

\textbf{Definiteness}

An algorithm needs to have exact definitions for each step. Clear and
straightforward directions ensure that every step is understood and can
be taken easily.

\textbf{Input}

An algorithm requires one or more inputs. The values that are first
supplied to the algorithm before its processing are known as inputs.
These inputs come from a predetermined range of acceptable values.

\textbf{Output}

One or more outputs must be produced by an algorithm. The output is the
outcome of the algorithm after every step has been completed. The
relationship between the input and the result should be clear.

\textbf{Effectiveness}

An algorithm's stages must be sufficiently straightforward to be carried
out in a finite time utilizing fundamental operations. With the
resources at hand, every operation in the algorithm should be doable and
practicable.

\textbf{Generality}

Rather than being limited to a single particular case, an algorithm
should be able to solve a group of issues. It should offer a generic fix
that manages a variety of inputs inside a predetermined range or domain.

\end{tcolorbox}

\subsubsection*{Factors of an Algorithm}\label{factors-of-an-algorithm}
\addcontentsline{toc}{subsubsection}{Factors of an Algorithm}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Factors}\vspace{3mm}

\texttt{**Modularity**}

This feature was perfectly designed for the algorithm if you are given a
problem and break it down into small-small modules or small-small steps,
which is a basic definition of an algorithm.

\textbf{Correctness}

An algorithm's correctness is defined as when the given inputs produce
the desired output, indicating that the algorithm was designed
correctly. An algorithm's analysis has been completed correctly.

\textbf{Maintainability}

It means that the algorithm should be designed in a straightforward,
structured way so that when you redefine the algorithm, no significant
changes are made to the algorithm.

\textbf{Functionality}

It takes into account various logical steps to solve a real-world
problem.

\textbf{Robustness}

Robustness refers to an algorithm's ability to define your problem
clearly.

\textbf{User-friendly}

If the algorithm is difficult to understand, the designer will not
explain it to the programmer.

\textbf{Simplicity}

If an algorithm is simple, it is simple to understand.

\texttt{**Extensibility**}

Your algorithm should be extensible if another algorithm designer or
programmer wants to use it.

\end{tcolorbox}

\subsubsection*{Types of Algorithms}\label{types-of-algorithms}
\addcontentsline{toc}{subsubsection}{Types of Algorithms}

\section{Type-1}

\url{https://youtu.be/BYWf6-tpQ4k}

\textbf{Brute Force Algorithm}

A straightforward approach that exhaustively tries all possible
solutions, suitable for small problem instances but may become
impractical for larger ones due to its high time complexity.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/ivl5-snqul8}

\textbf{Recursive Algorithm}

A method that breaks a problem into smaller, similar subproblems and
repeatedly applies itself to solve them until reaching a base case,
making it effective for tasks with recursive structures.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/0TCY1rfpjxc}

\textbf{Encryption Algorithm}

Utilized to transform data into a secure, unreadable form using
cryptographic techniques, ensuring confidentiality and privacy in
digital communications and transactions.

\section{Type-2}

\url{https://youtu.be/RtpJOGvfo7E}

\textbf{Backtracking Algorithm}

A trial-and-error technique used to explore potential solutions by
undoing choices when they lead to an incorrect outcome, commonly
employed in puzzles and optimization problems.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/ZpFqAoO4YPc}

\textbf{Searching Algorithm}

Designed to find a specific target within a data set, enabling efficient
retrieval of information from sorted or unsorted collections.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/rbbTd-gkajw}

\textbf{Sorting Algorithm}

Aimed at arranging elements in a specific order, like numerical or
alphabetical, to enhance data organization and retrieval.

\section{Type-3}

\url{https://youtu.be/WEILxTBDy0Y}

\url{https://youtu.be/FsfRsGFHuv4}

\textbf{Hashing Algorithm}

Converts data into a fixed-size hash value, enabling rapid data access
and retrieval in hash tables, commonly used in databases and password
storage.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/ib4BHvr5-Ao}

\textbf{Divide \& Conquer Algorithm}

Breaks a complex problem into smaller subproblems, solves them
independently, and then combines their solutions to address the original
problem effectively.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/hDDrIw_DSto}

\textbf{Greedy Algorithm}

Makes locally optimal choices at each step in the hope of finding a
global optimum, useful for optimization problems but may not always lead
to the best solution.

\section{Type-4}

\url{https://youtu.be/vYquumk4nWw}

\textbf{Dynamic Programming Algorithm}

Stores and reuses intermediate results to avoid redundant computations,
enhancing the efficiency of solving complex problems.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\url{https://youtu.be/8t9RaIQzp_o}

\textbf{Randomized Algorithm}

Utilizes randomness in its steps to achieve a solution, often used in
situations where an approximate or probabilistic answer suffices.

\subsubsection*{Recursive Algorithms}\label{recursive-algorithms}
\addcontentsline{toc}{subsubsection}{Recursive Algorithms}

\paragraph*{Algorithms}\label{algorithms}
\addcontentsline{toc}{paragraph}{Algorithms}

Recursive algorithms are a fundamental concept in computer science,
particularly in the study of data structures and algorithms. A recursive
algorithm is one that solves a problem by breaking it down into smaller
instances of the same problem, which it then solves in the same way.
This process continues until the problem is reduced to a base case,
which is solved directly without further recursion.

\paragraph*{Key Concepts}\label{key-concepts}
\addcontentsline{toc}{paragraph}{Key Concepts}

\section{Base Case}

This is the condition under which the recursion stops. It represents the
simplest instance of the problem, which can be solved directly without
further recursion.

\section{Recursive Case}

This is the part of the algorithm that breaks the problem down into
smaller instances of the same problem and then calls the algorithm
recursively on these smaller instances.

\section{Stack}

Each recursive call is placed on the system call stack. When the base
case is reached, the stack begins to unwind as each instance of the
function returns its result.

\paragraph*{Factorial Calculation}\label{factorial-calculation}
\addcontentsline{toc}{paragraph}{Factorial Calculation}

The factorial of a number n (denoted as n!) is a classic example of a
recursive algorithm. The factorial is defined as:

\begin{itemize}
\tightlist
\item
  O! = 1 \emph{(Base Case)}
\item
  N! = n * (n-1)! For n \textgreater{} O \emph{(Recursive Case)}
\end{itemize}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ factorial(n):}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{0}\NormalTok{:  }\CommentTok{\# Base Case}
        \ControlFlowTok{return} \DecValTok{1}
    \ControlFlowTok{else}\NormalTok{:  }\CommentTok{\# Recursive Case}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial(n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Logic}

\textbf{How It Works:}

\begin{itemize}
\tightlist
\item
  Base Case: When n is 0, the function returns 1.
\item
  Recursive Case: For any other value of n, the function calls itself
  with n‚àí1 and multiplies the result by n.
\end{itemize}

For example, calling \texttt{factorial(3)} would work as follows:

\begin{itemize}
\tightlist
\item
  \texttt{factorial(3)} calls \texttt{factorial(2)}
\item
  \texttt{factorial(2)} calls \texttt{factorial(1)}
\item
  \texttt{factorial(1)} calls \texttt{factorial(0)}
\item
  \texttt{factorial(0)} returns 1, then:
\item
  \texttt{factorial(1)} returns 1 * 1 = 1
\item
  \texttt{factorial(2)} returns 2 * 1 = 2
\item
  \texttt{factorial(3)} returns 3 * 2 = 6
\end{itemize}

\section{Pros/Cons}

\textbf{Advantages of Recursion}

\begin{itemize}
\tightlist
\item
  \textbf{Simplicity:} Recursive solutions are often more elegant and
  easier to understand than their iterative counterparts.
\item
  \textbf{Direct Translation:} Some problems are naturally recursive,
  like tree traversals, making recursion the most straightforward
  approach.
\end{itemize}

\textbf{Disadvantages of Recursion}

\begin{itemize}
\tightlist
\item
  \textbf{Performance:} Recursive algorithms can be less efficient due
  to the overhead of multiple function calls and potential stack
  overflow issues for deep recursion.
\item
  \textbf{Memory Usage:} Recursion can consume more memory because each
  function call adds a new frame to the call stack.
\end{itemize}

\section{Usage}

\textbf{When to Use Recursion} - When a problem can naturally be divided
into similar sub-problems \emph{(e.g., tree traversal, searching
algorithms like binary search)}. - When the recursive solution is
significantly simpler or more intuitive than an iterative one.

\paragraph*{Linear \& Binary Search}\label{linear-binary-search}
\addcontentsline{toc}{paragraph}{Linear \& Binary Search}

Linear search and binary search are two fundamental algorithms used to
search for an element in a collection, like an array or a list. However,
they differ significantly in how they approach the search and their
efficiency.

\subparagraph*{\texorpdfstring{\emph{Linear
Search}}{Linear Search}}\label{linear-search}
\addcontentsline{toc}{subparagraph}{\emph{Linear Search}}

\section{Concept}

\begin{itemize}
\tightlist
\item
  Linear search is the simplest search algorithm.
\item
  It works by sequentially checking each element of the array or list
  until the target element is found or the end of the collection is
  reached.
\end{itemize}

\section{Steps}

\textbf{Algorithm:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start from the first element of the array.
\item
  Compare the current element with the target element.
\item
  If they match, return the index of the element.
\item
  If they don't match, move to the next element and repeat the process.
\item
  If the target element is not found by the end of the array, return a
  ``not found'' indication.
\end{enumerate}

\textbf{Time Complexity:} \(O(n)\), where n is the number of elements in
the array. This is because in the worst case, the algorithm may need to
check every element in the array.

\section{Usage}

\textbf{When to Use:}

\begin{itemize}
\tightlist
\item
  When the array or list is small.
\item
  When the array is unsorted.
\item
  When simplicity is more important than performance.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ linear\_search(arr, target):}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(arr)):}
        \ControlFlowTok{if}\NormalTok{ arr[i] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ i}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}  \CommentTok{\# Return {-}1 if the element is not found}
\end{Highlighting}
\end{Shaded}

\subparagraph*{\texorpdfstring{\emph{Binary
Search}}{Binary Search}}\label{binary-search}
\addcontentsline{toc}{subparagraph}{\emph{Binary Search}}

\section{Concept}

\begin{itemize}
\tightlist
\item
  Binary search is much more efficient than linear search but requires
  the array or list to be sorted.
\item
  It works by repeatedly dividing the search interval in half. If the
  target value is less than the middle element, the search continues in
  the left half, otherwise in the right half.
\end{itemize}

\section{Steps}

\textbf{Algorithm:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start with two pointers, one at the beginning (low) and one at the end
  (high) of the sorted array.
\item
  Find the middle element of the current interval.
\item
  Compare the middle element with the target:

  \begin{itemize}
  \tightlist
  \item
    If they match, return the index of the middle element.
  \item
    If the target is less than the middle element, repeat the search on
    the left half.
  \item
    If the target is greater, repeat the search on the right half.
  \end{itemize}
\item
  If the interval becomes invalid (low \textgreater{} high), return a
  ``not found'' indication.
\end{enumerate}

\textbf{Time Complexity:} \(\text{O(log‚Å° n)}\), where n is the number of
elements in the array. This logarithmic time complexity makes binary
search significantly faster than linear search for large data sets.

\section{Usage}

\textbf{When to Use:}

\begin{itemize}
\tightlist
\item
  When the array or list is sorted.
\item
  When the array is large and efficiency is crucial.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ binary\_search(arr, target):}
\NormalTok{    low }\OperatorTok{=} \DecValTok{0}
\NormalTok{    high }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(arr) }\OperatorTok{{-}} \DecValTok{1}

    \ControlFlowTok{while}\NormalTok{ low }\OperatorTok{\textless{}=}\NormalTok{ high:}
\NormalTok{        mid }\OperatorTok{=}\NormalTok{ (low }\OperatorTok{+}\NormalTok{ high) }\OperatorTok{//} \DecValTok{2}
        \ControlFlowTok{if}\NormalTok{ arr[mid] }\OperatorTok{==}\NormalTok{ target:}
            \ControlFlowTok{return}\NormalTok{ mid}
        \ControlFlowTok{elif}\NormalTok{ arr[mid] }\OperatorTok{\textless{}}\NormalTok{ target:}
\NormalTok{            low }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{+} \DecValTok{1}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            high }\OperatorTok{=}\NormalTok{ mid }\OperatorTok{{-}} \DecValTok{1}

    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}  \CommentTok{\# Return {-}1 if the element is not found}
\end{Highlighting}
\end{Shaded}

\section{Compare}

\textbf{Comparison}

\begin{itemize}
\tightlist
\item
  \textbf{Efficiency:} Binary search is faster than linear search,
  especially for large data sets, but it requires the array to be
  sorted.
\item
  \textbf{Simplicity:} Linear search is simpler to implement and doesn't
  require the array to be sorted, making it more versatile for smaller
  or unsorted data sets.
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Linear Search:} Suitable for small or unsorted collections
    where the simplicity of the algorithm outweighs the need for speed.
  \item
    \textbf{Binary Search:} Ideal for large, sorted collections where
    performance is a priority.
  \end{itemize}
\end{itemize}

\subparagraph*{\texorpdfstring{\emph{Step-by-Step
Guide}}{Step-by-Step Guide}}\label{step-by-step-guide}
\addcontentsline{toc}{subparagraph}{\emph{Step-by-Step Guide}}

\section{Arrays}

Figuring out the array elements that correspond to the mid-values in the
first and second iterations of A binary search

\(\text{ arr = {45, 77, 89, 90, 94, 99, 100} }\) and
\(\text{key = 100}\)

\section{Setup}

\begin{itemize}
\tightlist
\item
  The array \texttt{arr} is
  \texttt{\{45,\ 77,\ 89,\ 90,\ 94,\ 99,\ 100\}}.
\item
  The \texttt{key} to find is \texttt{100}.
\item
  Initialize two pointers: \texttt{low} (start of the array) and
  \texttt{high} (end of the array).
\end{itemize}

\section{1st Iteration}

\begin{itemize}
\item
  Calculate the middle index \texttt{mid} using the formula:
  \texttt{mid\ =\ (low\ +\ high)\ /\ 2}
\item
  Check the value at \texttt{arr{[}mid{]}}.
\item
  Compare \texttt{arr{[}mid{]}} with the \texttt{key}:

  \begin{itemize}
  \tightlist
  \item
    If \texttt{arr{[}mid{]}} is less than \texttt{key}, update
    \texttt{low} to \texttt{mid} + 1.
  \item
    If \texttt{arr{[}mid{]}} is greater than \texttt{key}, update
    \texttt{high} to \texttt{mid} - 1.
  \item
    If \texttt{arr{[}mid{]}} is equal to \texttt{key}, you have found
    the \texttt{key} (though you won't need a second iteration in this
    case).
  \end{itemize}
\end{itemize}

\section{2nd Iteration}

\begin{itemize}
\tightlist
\item
  Repeat the calculation for \texttt{mid} with the updated \texttt{low}
  and \texttt{high} values.
\item
  Again, compare \texttt{arr{[}mid{]}} with the \texttt{key} and update
  \texttt{low} or \texttt{high} accordingly.
\end{itemize}

\subsubsection*{Searching Algorithms}\label{searching-algorithms}
\addcontentsline{toc}{subsubsection}{Searching Algorithms}

\paragraph*{Linear Search}\label{linear-search-1}
\addcontentsline{toc}{paragraph}{Linear Search}

\section{Logic}

\begin{itemize}
\tightlist
\item
  \textbf{Concept:} As discussed earlier, linear search involves
  checking each element in a list or array sequentially until the target
  element is found or the end of the collection is reached.
\item
  \textbf{Time Complexity:} \(O(n)\), where n is the number of elements.
\end{itemize}

\section{Usage}

\begin{itemize}
\item
  \textbf{Use Case:} Best used when the list is small or unsorted.
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Simple, sequential search.
  \item
    Checks each element one by one.
  \item
    Works on both sorted and unsorted data.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Linear Search Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \texttt{**Best\ Case:**} \(O(1)\) --- The target element is the
    first element.
  \item
    \texttt{**Average\ Case:**} \(O(n)\) --- The target element is
    somewhere in the middle or not in the array.
  \item
    \texttt{**Worst\ Case:**} \(O(n)\) --- The target element is the
    last element or not present.
  \end{itemize}
\end{itemize}

\paragraph*{Binary Search}\label{binary-search-1}
\addcontentsline{toc}{paragraph}{Binary Search}

\section{Logic}

\begin{itemize}
\tightlist
\item
  \textbf{Concept:} Binary search operates on a sorted list. It
  repeatedly divides the search interval in half until the target
  element is found or the interval is empty.
\item
  \textbf{Time Complexity:} \(\text{O(log‚Å° n)}\)
\end{itemize}

\section{Usage}

\begin{itemize}
\item
  \textbf{Use Case:} Ideal for large, sorted datasets.
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    \texttt{Requires\ a\ sorted\ array.}
  \item
    Divides the search interval in half repeatedly.
  \item
    Efficient, logarithmic time complexity.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Binary Search Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(1)\) --- The target element is the middle
    element.
  \item
    \textbf{Average Case:} \(\text{O(log‚Å° n)}\) --- The target element is
    not immediately found but within the sorted array.
  \item
    \textbf{Worst Case:} \(\text{O(log‚Å° n)}\) --- The target element is
    at the extreme ends or not present.
  \end{itemize}
\end{itemize}

\paragraph*{Interpolation Search}\label{interpolation-search}
\addcontentsline{toc}{paragraph}{Interpolation Search}

\section{Logic}

\begin{itemize}
\tightlist
\item
  \textbf{Concept:} Similar to binary search but works on uniformly
  distributed data. It estimates the position of the target element
  based on the value.
\item
  \textbf{Time Complexity:} O(log ‚Å°log ‚Å°n) in the best case, \(O(n)\) in
  the worst case.
\end{itemize}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Effective when the data is uniformly distributed.
\end{itemize}

\section{States}

\begin{itemize}
\tightlist
\item
  Interpolation Search Worst, Average and Best

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(1)\) --- The target element is exactly where
    the interpolation suggests.
  \item
    \textbf{Average Case:} \(\text{O(log ‚Å°log‚Å° n)}\) --- Uniformly
    distributed data.
  \item
    \textbf{Worst Case:} \(O(n)\) --- Highly skewed data distribution or
    worst interpolation.
  \end{itemize}
\end{itemize}

\paragraph*{DFS/BFS}\label{dfsbfs}
\addcontentsline{toc}{paragraph}{DFS/BFS}

\section{Logic}

\begin{itemize}
\tightlist
\item
  \textbf{Concept:} Used primarily in graph and tree data structures.
  \textbf{Depth-First Search (DFS)} explores as far as possible along
  one branch before backtracking, while \textbf{Breadth-First Search
  (BFS)} explores all neighbors at the present depth before moving on to
  nodes at the next depth level.
\item
  \textbf{Time Complexity:} \(\text{O(V + E)}\), where V is the number
  of vertices and E is the number of edges.
\end{itemize}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Useful for searching nodes in graphs and trees.
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{(DFS)}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(1)\) --- The target node is found
    immediately.
  \item
    \textbf{Average Case:} \(\text{O(V + E)}\)--- Typically when all
    nodes and edges must be explored.
  \item
    \textbf{Worst Case:} \(\text{O(V + E)}\) --- The target node is the
    last one discovered.
  \end{itemize}
\item
  \textbf{(BFS)}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(1)\) --- The target node is the root or the
    first node checked.
  \item
    \textbf{Average Case:} \(\text{O(V + E)}\) --- All nodes and edges
    need to be explored.
  \item
    \textbf{Worst Case:} \(\text{O(V + E)}\) --- The target node is the
    last one explored.
  \end{itemize}
\end{itemize}

\subsubsection*{Sorting Algorithms}\label{sorting-algorithms}
\addcontentsline{toc}{subsubsection}{Sorting Algorithms}

Sorting algorithms organize data in a particular order \emph{(usually
ascending or descending)}. This makes searching and other operations
more efficient.

\paragraph*{Bubble Sort}\label{bubble-sort}
\addcontentsline{toc}{paragraph}{Bubble Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Simple but inefficient for large datasets. Best
  used for educational purposes or small lists.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Repeatedly swaps adjacent elements if they are in the wrong order.
  \item
    Simple, but inefficient for large datasets.
  \item
    ``Bubbles'' the largest element to the end of the list.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\tightlist
\item
  Bubble Sort Worst, Average and Best

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(n)\) --- The array is already sorted
    \emph{(with an optimized version that stops early)}.
  \item
    \textbf{Average Case:} \(O(n^2)\) --- Average case with random
    elements.
  \item
    \textbf{Worst Case:} \(O(n^2)\) --- The array is sorted in reverse
    order.
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Bubble:} Look for something that swaps so the result can
  ``bubble'' to the top. (Swap, Exchange)
\end{itemize}

\paragraph*{Selection Sort}\label{selection-sort}
\addcontentsline{toc}{paragraph}{Selection Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Inefficient for large lists, but useful when memory
  writes are more expensive than comparisons.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Finds the minimum element and swaps it with the first unsorted
    element.
  \item
    Reduces the problem size by one in each iteration.
  \item
    Always performs \(O(n^2)\) comparisons, regardless of input.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  Selection Sort Worst, Average and Best

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(n^2)\) --- Selection sort does not improve
    with better input, always \(O(n^2)\).
  \item
    \textbf{Average Case:} \(O(n^2)\) --- Average case with random
    elements.
  \item
    \textbf{Worst Case:} \(O(n^2)\) --- Selection sort is insensitive to
    input order.
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Selection:} Look for code that repeatedly finds the minimum
  \emph{(or maximum)} element and moves it to the beginning \emph{(or
  end)} of the list. \emph{(Select minimum, Swap with start)}
\end{itemize}

\paragraph*{Insertion Sort}\label{insertion-sort}
\addcontentsline{toc}{paragraph}{Insertion Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Good for small or nearly sorted lists.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Builds a sorted list one element at a time.
  \item
    Efficient for small or nearly sorted datasets.
  \item
    Shifts elements to make space for the current element.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Insertion Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(O(n)\) --- The array is already sorted.
  \item
    \textbf{Average Case:} \(O(n^2)\) --- Average case with random
    elements.
  \item
    \textbf{Worst Case:} \(O(n^2)\) --- The array is sorted in reverse
    order.
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Insertion:} Look for code that builds a sorted portion of the
  list one element at a time by inserting each new element into its
  correct position within the already-sorted part. \emph{(Insert, Shift
  Element)}
\end{itemize}

\paragraph*{Merge Sort}\label{merge-sort}
\addcontentsline{toc}{paragraph}{Merge Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Efficient and stable; good for large datasets.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Divides the list into halves, sorts each half, and then merges them.
  \item
    Stable and efficient for large datasets.
  \item
    Requires additional space for merging.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Merge Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n ‚Å°log‚Å° n)}\) --- Merge sort's time
    complexity is the same in all cases.
  \item
    \textbf{Average Case:} \(\text{O(n ‚Å°log‚Å° n)}\).
  \item
    \textbf{Worst Case:} \(\text{O(n ‚Å°log‚Å° n)}\).
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Merge:} Look for something that continually splits a list in
  half. \emph{(Merge, Split)}
\end{itemize}

\paragraph*{Quicksort}\label{quicksort}
\addcontentsline{toc}{paragraph}{Quicksort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Often faster in practice than merge sort but less
  stable.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Selects a \emph{``pivot''} element and partitions the array around
    it.
  \item
    Recursively sorts the partitions.
  \item
    Efficient, but can degrade to \(O(n^2)\) if poor pivot selection
    occurs.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Quicksort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n ‚Å°log‚Å° n)}\) --- The pivot splits the
    array into two nearly equal halves.
  \item
    \textbf{Average Case:} \(\text{O(n ‚Å°log‚Å° n)}\) --- Average case with
    random pivots.
  \item
    \textbf{Worst Case:} \(O(n^2)\) --- The pivot is always the smallest
    or largest element, leading to unbalanced partitions.
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Quicksort:} Look for the keywords \emph{``pivot''} and/or
  \emph{``split''}. \emph{(Pivot, Split)}
\end{itemize}

\paragraph*{Heap Sort}\label{heap-sort}
\addcontentsline{toc}{paragraph}{Heap Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Useful when memory usage is a concern as it's an
  in-place algorithm.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Utilizes a binary heap data structure.
  \item
    Builds a max-heap and repeatedly extracts the maximum element.
  \item
    Efficient and in-place, but not stable.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Heap Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n ‚Å°log‚Å° n)}\) --- Heap sort's time
    complexity is the same in all cases.
  \item
    \textbf{Average Case:} \(\text{O(n ‚Å°log‚Å° n)}\).
  \item
    \textbf{Worst Case:} \(\text{O(n ‚Å°log‚Å° n)}\).
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Heap Sort:} Look for code that uses a heap data structure to
  repeatedly extract the maximum \emph{(or minimum)} element and
  rebuilds the heap. \emph{(Heapify, Extract Max, Build Heap)}
\end{itemize}

\paragraph*{Counting Sort}\label{counting-sort}
\addcontentsline{toc}{paragraph}{Counting Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  Use Case: Efficient for sorting integers or other items with a small
  range of possible values.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Non-comparative sorting.
  \item
    Counts occurrences of each element and uses this information to
    place elements.
  \item
    Efficient for small ranges of integers.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Counting Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n ‚Å°+ k) - k}\) is the range of the
    input.
  \item
    \textbf{Average Case:} \(\text{O(n ‚Å°+ k)}\).
  \item
    \textbf{Worst Case:} \(\text{O(n ‚Å°+ k)}\).
  \end{itemize}
\end{itemize}

\paragraph*{Radix Sort}\label{radix-sort}
\addcontentsline{toc}{paragraph}{Radix Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Effective for sorting large numbers or strings with
  a fixed length.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Sorts numbers by processing individual digits.
  \item
    Non-comparative, stable, and efficient for specific data types.
  \item
    Often combined with counting sort.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Radix Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n ‚Å°* k)}\) --- k is the number of
    digits in the largest number.
  \item
    \textbf{Average Case:} \(\text{O(n ‚Å°* k)}\).
  \item
    \textbf{Worst Case:} \(\text{O(n ‚Å°* k)}\).
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Radix Sort:} Look for code that sorts numbers based on their
  individual digits, starting from the \textbf{least significant digit
  (LSD)} or the most \textbf{significant digit (MSD)}. \emph{(Count,
  Frequency, Sum)}
\end{itemize}

\paragraph*{Bucket Sort}\label{bucket-sort}
\addcontentsline{toc}{paragraph}{Bucket Sort}

\section{Usage}

\begin{itemize}
\tightlist
\item
  \textbf{Use Case:} Good for uniformly distributed data.
\end{itemize}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Distributes elements into buckets and sorts each bucket
    individually.
  \item
    Efficient when the input is uniformly distributed.
  \item
    Often combined with another sorting algorithm like insertion sort.
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Bucket Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n + k)}\) --- k is the number of
    buckets; assumes uniform distribution.
  \item
    \textbf{Average Case:} \(\text{O(n + k)}\).
  \item
    \textbf{Worst Case:} \(O(n^2)\) --- All elements end up in one
    bucket \emph{(degenerate case)}.
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Bucket:} Look for something that distributes the values into
  ``buckets'' where they are individually sorted. \emph{(Bucket)}
\end{itemize}

\paragraph*{Shell Sort}\label{shell-sort}
\addcontentsline{toc}{paragraph}{Shell Sort}

\section{Descriptor}

\begin{itemize}
\item
  \textbf{Distinct Characteristics:}

  \begin{itemize}
  \tightlist
  \item
    Generalization of insertion sort with a gap sequence.
  \item
    Sorts elements far apart and gradually reduces the gap.
  \item
    Efficient for medium-sized datasets.
  \item
    Time Complexity: Depends on the gap sequence; commonly
    \(\text{O(n3/2)}\).
  \end{itemize}
\end{itemize}

\section{States}

\begin{itemize}
\item
  \textbf{Shell Sort Worst, Average and Best}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Best Case:} \(\text{O(n log n)}\) --- Occurs when the array
    is already sorted or nearly sorted, especially when using a good gap
    sequence like the Knuth sequence.
  \item
    \textbf{Average Case:} \(O(n^(3/2))\) or \(O(n^1.5)\) --- Highly
    dependent on the gap sequence used. With commonly used sequences
    like the Knuth sequence, the average-case complexity is
    approximately \(O(n^1.5)\).
  \item
    \textbf{Worst Case:} \({O(n^2)}\) --- Can degrade to \({O(n^2)}\),
    particularly with poorly chosen gap sequences like the original
    Shell sequence \emph{(where the gaps are halved each time)}
  \end{itemize}
\end{itemize}

\section{Tips}

\begin{itemize}
\tightlist
\item
  \textbf{Shell Sort:} Look for code that sorts elements at specific
  intervals and gradually reduces the interval until it performs a final
  insertion sort. \emph{(Gap, Interval)}
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Summary}}{Summary}}\label{summary}
\addcontentsline{toc}{subparagraph}{\textbf{Summary}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Searching \& Sorting Algorithms}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Linear Search:} Simple, sequential; \(O(n)\).
\item
  \textbf{Binary Search:} Sorted data, divide and conquer;
  \(\text{O(log n)}\).
\item
  \textbf{Bubble Sort:} Swaps, bubbles up; \(O(n^2)\).
\item
  \textbf{Selection Sort:} Finds minimum, swaps; \(O(n^2)\).
\item
  \textbf{Insertion Sort:} Builds sorted list, shifts; \(O(n^2)\),
  \(O(n)\) best case.
\item
  \textbf{Merge Sort:} Divide and conquer, merge; \(\text{O(n log n)}\).
\item
  \textbf{Quick Sort:} Pivot, partition; \(\text{O(n log n)}\) average,
  \(O(n^2)\) worst case.
\item
  \textbf{Heap Sort:} Max-heap, extract max; \(\text{O(n log n)}\).
\item
  \textbf{Counting Sort:} Counts occurrences, non-comparative;
  \(\text{O(n + k)}\).
\item
  \textbf{Radix Sort:} Sorts by digits, non-comparative; \(O(nk)\).
\item
  \textbf{Bucket Sort:} Distributes into buckets, sorts;
  \(\text{O(n + k)}\).
\item
  \textbf{Shell Sort:} Gap sequence, insertion-like; \(O(n^3/2)\).
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Key Observations}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Bubble Sort, Selection Sort, and Insertion Sort:} These are
  simple but inefficient for large datasets, especially in the worst
  case.
\item
  \textbf{Merge Sort and Heap Sort:} Stable and consistent in
  performance, regardless of the input.
\item
  \textbf{Quick Sort:} Very efficient on average but can degrade to
  \(O(n^2)\) in the worst case without proper pivot selection.
\item
  \textbf{Counting Sort, Radix Sort, and Bucket Sort:} Efficient for
  specific types of data \emph{(e.g., integers within a fixed range)}
  but less versatile.
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Choosing the Right Algorithm}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Small datasets:} Simpler algorithms like bubble sort,
  selection sort, or insertion sort might suffice.
\item
  \textbf{Large datasets:} More efficient algorithms like merge sort,
  quick sort, or heap sort are preferred.
\item
  \textbf{Sorted data:} Algorithms like insertion sort can be very
  efficient.
\item
  \textbf{Special conditions:} Use counting sort, radix sort, or bucket
  sort if the data is within a certain range or has other specific
  properties.
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection*{Big O Notation}\label{big-o-notation}
\addcontentsline{toc}{subsubsection}{Big O Notation}

\textbf{What is Big O Notation?}

\begin{itemize}
\tightlist
\item
  \textbf{Big O Notation:} It provides an upper bound on the time or
  space complexity of an algorithm, representing the worst-case
  scenario. It's a way to describe the efficiency of an algorithm as the
  input size grows towards infinity.
\end{itemize}

\textbf{Why Use Big O Notation?}

\begin{itemize}
\tightlist
\item
  \textbf{Comparing Algorithms:} It allows us to compare the efficiency
  of different algorithms independently of hardware or other
  environmental factors.
\item
  \textbf{Scalability:} It helps us understand how an algorithm will
  perform as the size of the input data grows.
\end{itemize}

\paragraph*{O Notations}\label{o-notations}
\addcontentsline{toc}{paragraph}{O Notations}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Common Big Os}\vspace{3mm}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{\texttt{O(1)\ -\ Constant\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The algorithm takes the same amount of time to
    execute regardless of the size of the input.
  \item
    \textbf{Example:} Accessing an element in an array by index.
  \item
    \textbf{Efficiency:} Excellent.
  \end{itemize}
\item
  \textbf{\texttt{O(log\ n)\ -\ Logarithmic\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime increases logarithmically as the
    input size increases. Typically occurs in algorithms that halve the
    problem size at each step, like binary search.
  \item
    \textbf{Example:} Binary search.
  \item
    \textbf{Efficiency:} Very good for large inputs.
  \end{itemize}
\item
  \textbf{\texttt{O(n)\ -\ Linear\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime increases linearly with the size
    of the input. If you double the input size, the runtime also
    doubles.
  \item
    \textbf{Example:} Linear search, iterating through a list.
  \item
    \textbf{Efficiency:} Reasonable for moderate to large inputs.
  \end{itemize}
\item
  \textbf{\texttt{O(n\ log\ n)\ -\ Log-Linear\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime increases more than linearly but
    less than quadratically. Common in efficient sorting algorithms like
    merge sort and quicksort.
  \item
    \textbf{Example:} Merge sort, quicksort, heap sort.
  \item
    \textbf{Efficiency:} Efficient for large inputs.
  \end{itemize}
\item
  \textbf{\texttt{O(n\^{}2)\ -\ Quadratic\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime increases quadratically with the
    size of the input. If you double the input size, the runtime
    quadruples.
  \item
    \textbf{Example:} Bubble sort, insertion sort, selection sort
    \emph{(for unsorted arrays)}.
  \item
    \textbf{Efficiency:} Poor for large inputs.
  \end{itemize}
\item
  \textbf{\texttt{O(2n)\ -\ Exponential\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime doubles with each additional
    element in the input. Common in algorithms that solve problems by
    brute force or explore all possible solutions.
  \item
    \textbf{Example:} Recursive algorithms for the Fibonacci sequence,
    certain dynamic programming problems.
  \item
    \textbf{Efficiency:} Very poor, impractical for large inputs.
  \end{itemize}
\item
  \textbf{\texttt{O(n!)\ -\ Factorial\ Time}:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The runtime increases factorially with the
    size of the input. Common in algorithms that generate all
    permutations of an input set.
  \item
    \textbf{Example:} Traveling salesman problem via brute force.
  \item
    \textbf{Efficiency:} Extremely poor, infeasible for even moderate
    input sizes.
  \end{itemize}
\end{enumerate}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Time Complexity}\vspace{3mm}

\textbf{Best Case, Worst Case, and Average Case}

\begin{itemize}
\tightlist
\item
  \textbf{Best Case:} The scenario where the algorithm performs the
  minimum possible number of operations. It's often less relevant
  because it's optimistic.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Example:} For linear search, the best case is \(O(1)\),
    where the target element is the first one in the array.
  \end{itemize}
\item
  \textbf{Worst Case:} The scenario where the algorithm performs the
  maximum possible number of operations. Big O notation typically
  describes the worst-case complexity.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Example:} For linear search, the worst case is \(O(n)\),
    where the target element is the last one in the array or isn't
    present at all.
  \end{itemize}
\item
  \textbf{Average Case:} The scenario that represents the expected
  number of operations for a typical input. It's more complex to
  calculate because it depends on the distribution of inputs.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Example:} For linear search, the average case is \(O(n/2)\),
    but in Big O notation, we simplify this to \(O(n)\).
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Calculation Rules}\vspace{3mm}

\textbf{Ignore Constants:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} In Big O notation, constant factors are ignored.
\item
  \textbf{Why:} Big O notation focuses on the growth rate as the input
  size \((n)\) increases, so a constant multiplier doesn't affect the
  growth rate.
\item
  \textbf{Example:} \(O(2n)\) simplifies to \(O(n)\)
\end{itemize}

\textbf{Focus on the Dominant Term:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} Only the term with the highest growth rate is
  considered.
\item
  \textbf{Why:} As n becomes large, the term with the highest growth
  rate will dominate the others.
\item
  \textbf{Example:} \(O(n2+n)\) simplifies to \(O(n2)\)
\end{itemize}

\textbf{Drop Lower Order Terms:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} Lower-order terms are ignored because they become
  insignificant as n grows.
\item
  \textbf{Why:} Similar to focusing on the dominant term, lower-order
  terms have a negligible impact on large inputs.
\item
  \textbf{Example:} \(O(n2 + n + log n)\) simplifies to \(O(n2)\)
\end{itemize}

\textbf{Multiplicative Constants Can Be Ignored:} - \textbf{Rule:}
Coefficients that multiply variables \emph{(e.g., 2n, 3n\^{}2)} are
ignored. - \textbf{Why:} Like constants, they don't change the growth
rate. - \textbf{Example:} \(O(3n2)\) simplifies to \(O(n2)\)

\textbf{Additive Constants Can Be Ignored:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} Constant terms that don't depend on n are ignored.
\item
  \textbf{Why:} They don't affect the overall growth rate as n
  increases.
\item
  \textbf{Example:} \(O(n+10)\) simplifies to \(O(n)\)
\end{itemize}

\textbf{Logarithms with Different Bases:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} Logarithms with different bases can be considered
  equivalent in Big O notation.
\item
  \textbf{Why:} Changing the base of a logarithm only introduces a
  constant factor, which is ignored in Big O notation.
\item
  \textbf{Example:} \(\text{O(log‚Å°2 n)}\) simplifies to
  \(\text{O(log‚Å° n)}\)
\end{itemize}

\textbf{Non-Dominant Polynomial Terms:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} In polynomials, only the highest degree term is
  considered.
\item
  \textbf{Why:} As n grows large, the highest degree term will dominate.
\item
  \textbf{Example:} \(\text{O(5n3 + 2n2 + 7)}\) simplifies to \(O(n3)\)
\end{itemize}

\textbf{Exponential Growth:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} Exponential growth functions dominate polynomial
  functions.
\item
  \textbf{Why:} Exponential functions grow much faster than polynomial
  functions as n increases.
\item
  \textbf{Example:} \(\text{O(2n + n3)}\) simplifies to \(O(2n)\)
\end{itemize}

\textbf{Nested Loops:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} The time complexity of nested loops is the product of
  the complexities of each loop.
\item
  \textbf{Why:} Each loop iterates based on the input size, so their
  combined effect is multiplicative.
\item
  \textbf{Example:} A loop inside another loop both running n times
  results in \(\text{O(n * n) = O(n2)}\)
\end{itemize}

\textbf{Sequential Statements:}

\begin{itemize}
\tightlist
\item
  \textbf{Rule:} If two independent statements \emph{(or loops)} are
  executed sequentially, their time complexities are added.
\item
  \textbf{Why:} Sequential operations don't multiply time complexity,
  but rather add up.
\item
  \textbf{Example:} Two loops each running n times sequentially result
  in \(\text{O(n + n) = O(n)}\)
\end{itemize}

\end{tcolorbox}

\section*{Determines Data Structure Impact -
(31\%)}\label{determines-data-structure-impact---31}
\addcontentsline{toc}{section}{Determines Data Structure Impact -
(31\%)}

\markright{Determines Data Structure Impact - (31\%)}

\subsubsection*{Implementation of Data
Structures}\label{implementation-of-data-structures}
\addcontentsline{toc}{subsubsection}{Implementation of Data Structures}

\paragraph*{Data Types}\label{data-types}
\addcontentsline{toc}{paragraph}{Data Types}

\section{Definition}

\textbf{What is a Data Type?}

\textbf{Definition:} A data type is a classification that specifies the
type of data that a variable can hold in programming. It defines the
operations that can be performed on the data and the way the data is
stored in memory.

\section{Examples}

\begin{itemize}
\item
  \textbf{Primitive Data Types:} These are the basic building blocks of
  data in a programming language.

  \begin{itemize}
  \tightlist
  \item
    Integer \emph{(e.g., \texttt{int} in C, Java)}: Holds whole numbers.
  \item
    Floating Point \emph{(e.g., \texttt{float}, \texttt{double})}: Holds
    numbers with fractional parts.
  \item
    Character \emph{(e.g., \texttt{char})}: Holds a single character.
  \item
    Boolean \emph{(e.g., \texttt{bool})}: Holds a \texttt{true} or
    \texttt{false} value.
  \end{itemize}
\item
  \textbf{Composite Data Types:} These are constructed from primitive
  types.

  \begin{itemize}
  \tightlist
  \item
    Arrays: A collection of elements of the same data type.
  \item
    Structures \emph{(e.g., \texttt{struct} in C)}: A collection of
    different data types.
  \end{itemize}
\item
  \textbf{User-Defined Data Types:} Created by the user, typically by
  combining primitive data types.

  \begin{itemize}
  \tightlist
  \item
    Enumerations \texttt{(enum)}, Classes, etc.
  \end{itemize}
\end{itemize}

\section{Extra}

\textbf{Enumeration:}

\begin{itemize}
\tightlist
\item
  Enumeration, often referred to as \emph{``enum,''} is a data type in
  programming that allows a variable to be a set of predefined
  constants.
\item
  These constants are typically related and represent a set of possible
  values that a variable of the enumeration type can hold.
\item
  Enums improve code readability, make it easier to manage sets of
  related values, and reduce errors by limiting the values a variable
  can take.
\end{itemize}

\textbf{Key Concepts of Enumeration:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Definition:} An enumeration is defined using the enum keyword
  \emph{(syntax can vary by language)}. It consists of a set of named
  constants, each representing a unique value.
\item
  \textbf{Values:} The values in an enum are usually integers by
  default, starting from 0, but they can be assigned specific values as
  needed.
\item
  \textbf{Usage:} Enums are commonly used when a variable can only take
  one out of a small set of possible values, like days of the week,
  directions, states, etc.
\end{enumerate}

\textbf{Example in Different Languages:}

C/C++

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Direction }\OperatorTok{\{}
\NormalTok{    NORTH}\OperatorTok{,}
\NormalTok{    EAST}\OperatorTok{,}
\NormalTok{    SOUTH}\OperatorTok{,}
\NormalTok{    WEST}
\OperatorTok{\};}

\NormalTok{Direction dir }\OperatorTok{=}\NormalTok{ NORTH}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Java

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{enum}\NormalTok{ Direction \{}
\NormalTok{    NORTH}\OperatorTok{,}
\NormalTok{    EAST}\OperatorTok{,}
\NormalTok{    SOUTH}\OperatorTok{,}
\NormalTok{    WEST}
\NormalTok{\}}

\NormalTok{Direction dir }\OperatorTok{=}\NormalTok{ Direction}\OperatorTok{.}\AttributeTok{NORTH}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Python (using enum module)

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ enum }\ImportTok{import}\NormalTok{ Enum}

\KeywordTok{class}\NormalTok{ Direction(Enum):}
\NormalTok{    NORTH }\OperatorTok{=} \DecValTok{1}
\NormalTok{    EAST }\OperatorTok{=} \DecValTok{2}
\NormalTok{    SOUTH }\OperatorTok{=} \DecValTok{3}
\NormalTok{    WEST }\OperatorTok{=} \DecValTok{4}

\BuiltInTok{dir} \OperatorTok{=}\NormalTok{ Direction.NORTH}
\end{Highlighting}
\end{Shaded}

\textbf{Advantages of Using Enums:} - Readability: Code is easier to
read and understand. - Maintainability: Easier to update and maintain
related values. - Type Safety: Prevents assigning invalid values to
variables of the enum type.

Enums are useful in scenarios where a variable should only be allowed to
take one out of a small set of specific values, helping prevent errors
and making the code clearer and more reliable.

\textbf{Key Characteristics:} - \textbf{Memory Allocation:} Data types
determine how much memory is allocated for storing the data. -
\textbf{Operations:} Each data type supports a set of operations, like
arithmetic operations for integers or concatenation for strings.

\paragraph*{Data Structures}\label{data-structures}
\addcontentsline{toc}{paragraph}{Data Structures}

\section{Definition}

\textbf{What is a Data Structure?}

\begin{itemize}
\tightlist
\item
  \textbf{Definition:} A data structure is a specific way of organizing
  and storing data in a computer so that it can be accessed and modified
  efficiently. Data structures use data types as their underlying
  foundation.
\end{itemize}

\section{Examples}

\begin{itemize}
\tightlist
\item
  \textbf{Arrays:} A collection of elements stored in contiguous memory
  locations.
\item
  \textbf{Linked Lists:} A series of connected nodes, where each node
  contains data and a reference to the next node.
\item
  \textbf{Stacks:} A collection of elements with Last-In-First-Out
  (LIFO) access.
\item
  \textbf{Queues:} A collection of elements with First-In-First-Out
  (FIFO) access.
\item
  \textbf{Trees:} A hierarchical structure with a root element and
  sub-elements called nodes.
\item
  \textbf{Graphs:} A collection of nodes \emph{(vertices)} connected by
  edges.
\item
  \textbf{Hash Tables:} A data structure that maps keys to values for
  efficient lookup.
\end{itemize}

\paragraph*{Abstract Data Types (ADTs)}\label{abstract-data-types-adts}
\addcontentsline{toc}{paragraph}{Abstract Data Types (ADTs)}

\section{Definition}

\begin{itemize}
\tightlist
\item
  \textbf{Definition:} An abstract data type (ADT) is a theoretical
  model of a data structure that defines the behavior from the user's
  point of view, without specifying the underlying implementation. It
  specifies the operations that can be performed and the expected
  behavior but not how these operations are carried out.
\end{itemize}

\section{Examples}

\begin{itemize}
\tightlist
\item
  \textbf{List ADT:} Operations include insertion, deletion, and access
  by index.
\item
  \textbf{Stack ADT:} Operations include \texttt{push}, \texttt{pop},
  and \texttt{peek}.
\item
  \textbf{Queue ADT:} Operations include \texttt{enqueue} and
  \texttt{dequeue}.
\item
  \textbf{Map (or Dictionary) ADT:} Operations include inserting,
  deleting, and searching for key-value pairs.
\end{itemize}

\paragraph*{Differences}\label{differences}
\addcontentsline{toc}{paragraph}{Differences}

\section{1. Abstraction}

\begin{itemize}
\tightlist
\item
  \textbf{Data Types:} The most basic level; concerned with how data is
  stored and what operations are allowed.
\item
  \textbf{Data Structures:} A step higher in abstraction; concerned with
  how data is organized and accessed.
\item
  \textbf{ADTs:} The highest level of abstraction; concerned with the
  operations and behavior of a data structure, abstracted away from the
  implementation details.
\end{itemize}

\section{2. Purpose}

\begin{itemize}
\tightlist
\item
  \textbf{Data Types:} Define the type and nature of the data.
\item
  \textbf{Data Structures:} Provide a way to organize and manage data
  efficiently.
\item
  \textbf{ADTs:} Define a blueprint for data structures, focusing on
  what operations can be performed and what their expected behavior is.
\end{itemize}

\section{3. Implementation}

\begin{itemize}
\tightlist
\item
  \textbf{Data Types:} Directly supported by the programming language.
\item
  \textbf{Data Structures:} Built using data types and can be complex.
\item
  \textbf{ADTs:} Can be implemented using various data structures; the
  choice of implementation depends on the specific needs like
  performance and memory usage.
\end{itemize}

\section{4. Examples}

\begin{itemize}
\tightlist
\item
  \textbf{Data Types:} int, float, char, bool
\item
  \textbf{Data Structures:} Arrays, linked lists, trees, hash tables
\item
  \textbf{ADTs:} Stack, queue, list, set, map
\end{itemize}

\subparagraph*{Array}\label{array}
\addcontentsline{toc}{subparagraph}{Array}

\section{1. Description}

\begin{itemize}
\tightlist
\item
  An \textbf{array} is a collection of homogeneous elements stored in
  contiguous memory locations. Each element in the array can be accessed
  using its index.
\item
  \textbf{Python Equivalent:} \texttt{list}
\end{itemize}

\section{2. Operations}

\begin{itemize}
\item
  \textbf{Access:} \(O(1)\) --- Direct access to elements via index.
\item
  \textbf{Search:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Linear Search:} \(O(n)\)
  \item
    \textbf{Binary Search:} \(\text{O(log‚Å° n)}\) \emph{(only if the array
    is sorted)}
  \end{itemize}
\item
  Insertion:

  \begin{itemize}
  \tightlist
  \item
    \textbf{At the End:} Append the element to the end of the array. If
    the array is full \emph{(fixed size)}, you may need to resize it.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\) \emph{(amortized if resizing is
      needed)}.
    \end{itemize}
  \item
    \textbf{At a Specific Index:} Shift elements to the right from the
    index to create space, then insert the new element.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\), where n is the number of
      elements after the insertion point.
    \end{itemize}
  \end{itemize}
\item
  Deletion:

  \begin{itemize}
  \tightlist
  \item
    \textbf{From the End:} Remove the last element.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\).
    \end{itemize}
  \item
    \textbf{From a Specific Index:} Shift elements to the left to fill
    the gap left by the removed element.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\), where n is the number of
      elements after the removal point.
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{3. Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Suitable for scenarios where fast access to elements is required,
    and the size of the data set is known.
  \end{itemize}
\end{itemize}

\subparagraph*{Linked List}\label{linked-list}
\addcontentsline{toc}{subparagraph}{Linked List}

\section{Description}

\begin{itemize}
\tightlist
\item
  A linked list is a linear collection of elements called nodes, where
  each node contains data and a reference \emph{(or pointer)} to the
  next node in the sequence.
\item
  Python Equivalent: Custom class with Node and LinkedList classes
\end{itemize}

\section{Types}

\begin{itemize}
\tightlist
\item
  Singly Linked List: Each node points to the next node.
\item
  Doubly Linked List: Each node points to both the next and previous
  nodes.
\item
  Circular Linked List: The last node points back to the first node,
  forming a loop.
\end{itemize}

\section{Operations}

\begin{itemize}
\item
  \textbf{Access:} \(O(n)\) --- Requires traversal from the head to the
  desired node.
\item
  \textbf{Search:} \(O(n)\) --- Requires traversal to find the target
  element.
\item
  \textbf{Insertion:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{At the Beginning (Singly/ Doubly Linked List):} Create a new
    node and adjust the head \emph{(and possibly tail in a doubly linked
    list)}.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\).
    \end{itemize}
  \item
    \textbf{At the End (Singly Linked List):} Traverse to the last node,
    then insert the new node.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\).
    \end{itemize}
  \item
    \textbf{At a Specific Position:} Traverse to the position and insert
    the node, adjusting the pointers.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\).
    \end{itemize}
  \end{itemize}
\item
  \textbf{Deletion:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{From the Beginning:} Adjust the head pointer to the next
    node.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\).
    \end{itemize}
  \item
    \textbf{From the End:} Traverse to the second last node, adjust its
    pointer to null.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\).
    \end{itemize}
  \item
    \textbf{From a Specific Position:} Traverse to the node before the
    one to remove, then adjust pointers to bypass the removed node.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(n)\).
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Useful when the size of the data set is unknown or when frequent
    insertions and deletions are required.
  \end{itemize}
\end{itemize}

\subparagraph*{Methods for Lists/Arrays}\label{methods-for-listsarrays}
\addcontentsline{toc}{subparagraph}{Methods for Lists/Arrays}

\section{I \ldots{}}

\begin{itemize}
\tightlist
\item
  \textbf{append()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Adds an element to the end of the list.
  \item
    \textbf{Syntax:} list.append(element)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{]}
\NormalTok{fruits.append(}\StringTok{"orange"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fruits)  }\CommentTok{\# Output: [\textquotesingle{}apple\textquotesingle{}, \textquotesingle{}banana\textquotesingle{}, \textquotesingle{}orange\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['apple', 'banana', 'orange']
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{extend()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Extends the list by appending elements from
    another iterable \emph{(e.g., another list)}.
  \item
    \textbf{Syntax:} list.extend(iterable)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers.extend([}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(numbers)  }\CommentTok{\# Output: [1, 2, 3, 4, 5]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4, 5]
\end{verbatim}

\section{II \ldots{}}

\textbf{insert()} - \textbf{Description:} Inserts an element at a
specific index in the list. - \textbf{Syntax:} list.insert(index,
element)

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{]}
\NormalTok{fruits.insert(}\DecValTok{1}\NormalTok{, }\StringTok{"orange"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fruits)  }\CommentTok{\# Output: [\textquotesingle{}apple\textquotesingle{}, \textquotesingle{}orange\textquotesingle{}, \textquotesingle{}banana\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['apple', 'orange', 'banana']
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{remove()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Removes the first occurrence of a specified
    value from the list.
  \item
    \textbf{Syntax:} list.remove(element)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"orange"}\NormalTok{]}
\NormalTok{fruits.remove(}\StringTok{"banana"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fruits)  }\CommentTok{\# Output: [\textquotesingle{}apple\textquotesingle{}, \textquotesingle{}orange\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['apple', 'orange']
\end{verbatim}

\section{III \ldots{}}

\begin{itemize}
\tightlist
\item
  \textbf{pop()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Removes and returns the element at the
    specified index. If no index is specified, it removes and returns
    the last element.
  \item
    \textbf{Syntax:} list.pop(index)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"orange"}\NormalTok{]}
\NormalTok{last\_fruit }\OperatorTok{=}\NormalTok{ fruits.pop()}
\BuiltInTok{print}\NormalTok{(last\_fruit)  }\CommentTok{\# Output: \textquotesingle{}orange\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
orange
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(fruits)      }\CommentTok{\# Output: [\textquotesingle{}apple\textquotesingle{}, \textquotesingle{}banana\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['apple', 'banana']
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{index()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Returns the index of the first occurrence of a
    specified value.
  \item
    \textbf{Syntax:} list.index(element, start, end)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"orange"}\NormalTok{]}
\NormalTok{index\_of\_banana }\OperatorTok{=}\NormalTok{ fruits.index(}\StringTok{"banana"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(index\_of\_banana)  }\CommentTok{\# Output: 1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

\section{IV \ldots{}}

\begin{itemize}
\tightlist
\item
  \textbf{count()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Returns the number of occurrences of a
    specified value in the list.
  \item
    \textbf{Syntax:} list.count(element)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"orange"}\NormalTok{, }\StringTok{"banana"}\NormalTok{]}
\NormalTok{count\_of\_banana }\OperatorTok{=}\NormalTok{ fruits.count(}\StringTok{"banana"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(count\_of\_banana)  }\CommentTok{\# Output: 2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{sort()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Sorts the elements of the list in ascending
    order \emph{(or descending order if specified)} in place.
  \item
    \textbf{Syntax:} list.sort(reverse=False)
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{9}\NormalTok{]}
\NormalTok{numbers.sort()}
\BuiltInTok{print}\NormalTok{(numbers)  }\CommentTok{\# Output: [1, 1, 3, 4, 5, 9]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 1, 3, 4, 5, 9]
\end{verbatim}

\section{V \ldots{}}

\begin{itemize}
\tightlist
\item
  \textbf{reverse()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Reverses the elements of the list in place.
  \item
    \textbf{Syntax:} list.reverse()
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\NormalTok{numbers.reverse()}
\BuiltInTok{print}\NormalTok{(numbers)  }\CommentTok{\# Output: [4, 3, 2, 1]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[4, 3, 2, 1]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{copy()}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} Returns a shallow copy of the list.
  \item
    \textbf{Syntax:} list.copy()
  \end{itemize}
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fruits }\OperatorTok{=}\NormalTok{ [}\StringTok{"apple"}\NormalTok{, }\StringTok{"banana"}\NormalTok{, }\StringTok{"orange"}\NormalTok{]}
\NormalTok{fruits\_copy }\OperatorTok{=}\NormalTok{ fruits.copy()}
\BuiltInTok{print}\NormalTok{(fruits\_copy)  }\CommentTok{\# Output: [\textquotesingle{}apple\textquotesingle{}, \textquotesingle{}banana\textquotesingle{}, \textquotesingle{}orange\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['apple', 'banana', 'orange']
\end{verbatim}

\textbf{Java ArrayList Methods}

\begin{itemize}
\tightlist
\item
  \texttt{**add():**} Adds an element to the end of the list.
\item
  \texttt{**remove():**} Removes the first occurrence of a specified
  element.
\item
  \texttt{**get():**} Retrieves the element at a specified index.
\item
  \texttt{**set():**} Replaces the element at a specified index with a
  new element.
\item
  \texttt{**size():**} Returns the number of elements in the list.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{Record}\label{record}
\addcontentsline{toc}{paragraph}{Record}

\begin{itemize}
\tightlist
\item
  A \textbf{Record} is a composite data structure used to store a
  collection of related fields, each with a specific name and data type.
\item
  It is commonly used to model entities in databases and programming,
  allowing for structured and organized data storage.
\item
  Records are versatile and can represent complex objects with multiple
  attributes, making them essential in many applications.
\item
  In Python, a \textbf{Record} is typically implemented as a
  \textbf{class}, a \texttt{namedtuple}, or a \texttt{dataclass}. Each
  of these provides a way to group multiple fields \emph{(attributes)}
  together under one name, similar to how a record in other languages
  might work.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{Stack}\label{stack-1}
\addcontentsline{toc}{subparagraph}{Stack}

\subsubsection{Description}

\begin{itemize}
\tightlist
\item
  A \textbf{stack} is a linear data structure that follows the
  Last-In-First-Out (LIFO) principle, meaning the last element added is
  the first one to be removed.
\item
  \textbf{Python Equivalent:} \texttt{list} or
  \texttt{collections.deque}
\end{itemize}

\subsubsection{Operations}

\begin{itemize}
\tightlist
\item
  \textbf{Push (Insertion):} \(O(1)\) --- Add an element to the top of
  the stack.
\item
  \textbf{Pop (Deletion):} \(O(1)\) --- Remove the top element from the
  stack.
\item
  \textbf{Peek/Top:} \(O(1)\) --- View the top element without removing
  it.
\item
  \textbf{IsEmpty:} \(O(1)\) --- Check if the stack is empty.
\end{itemize}

\subsubsection{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Used in expression evaluation, backtracking algorithms, undo
    mechanisms in applications, and for maintaining function call stacks
    in recursion.
  \end{itemize}
\end{itemize}

\subparagraph*{Bag}\label{bag}
\addcontentsline{toc}{subparagraph}{Bag}

\subsubsection{Description}

\begin{itemize}
\tightlist
\item
  A \textbf{Bag} \emph{(also known as a multiset)} is a simple data
  structure that allows for storing a collection of elements where
  duplicate elements are allowed. Unlike a set, which requires all
  elements to be unique, a bag can contain multiple occurrences of the
  same element.
\item
  \textbf{Python Equivalent:} \texttt{collections.Counter}
\end{itemize}

\subsubsection{Operations}

\begin{itemize}
\tightlist
\item
  \textbf{Add (}\texttt{add}\textbf{)} --- Adds an element to the bag.

  \begin{itemize}
  \tightlist
  \item
    Simply add the element, usually at the end or beginning, depending
    on the implementation \emph{(array, linked list, etc.)}.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\).
    \end{itemize}
  \end{itemize}
\item
  \textbf{Check Membership (}\texttt{contains}\textbf{)} --- Checks if
  an element is in the bag.
\item
  \textbf{Count Occurrences (}\texttt{count}\textbf{)} --- Counts how
  many times an element appears in the bag.
\item
  \textbf{Remove (}\texttt{remove}\textbf{)} --- Removes one occurrence
  of an element from the bag.

  \begin{itemize}
  \tightlist
  \item
    Typically, bags do not have a direct remove operation unless
    implemented, in which case:

    \begin{itemize}
    \tightlist
    \item
      Remove Specific Element: Find the element and remove it, adjusting
      structure accordingly.

      \begin{itemize}
      \tightlist
      \item
        Time Complexity: \(O(n)\).
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  \textbf{Get Size (}\texttt{size}\textbf{)} --- Returns the total
  number of elements in the bag, including duplicates.
\end{itemize}

\subsubsection{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    A bag is useful when you need to count the number of occurrences of
    items, such as counting words in a document.
  \end{itemize}
\end{itemize}

\subparagraph*{Queue}\label{queue}
\addcontentsline{toc}{subparagraph}{Queue}

\subsubsection{Description}

\begin{itemize}
\tightlist
\item
  A \textbf{queue} is a linear data structure that follows the
  First-In-First-Out (FIFO) principle, meaning the first element added
  is the first one to be removed.
\item
  \textbf{Python Equivalent:} \texttt{collections.deque} or
  \texttt{queue.Queue}
\end{itemize}

\subsubsection{Operations}

\begin{itemize}
\tightlist
\item
  \textbf{Enqueue (Insertion/Push):} \(O(1)\) --- Add an element to the
  end of the queue.
\item
  \textbf{Dequeue (Deletion/Pop):} \(O(1)\) --- Remove the front element
  from the queue.
\item
  \textbf{Front/Peek:} \(O(1)\) --- View the front element without
  removing it.
\item
  \textbf{IsEmpty:} \(O(1)\) --- Check if the queue is empty.
\end{itemize}

\subsubsection{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Useful in scheduling processes, managing tasks in order,
    breadth-first search (BFS) algorithms, and handling requests in
    servers.
  \end{itemize}
\end{itemize}

\subparagraph*{Deque}\label{deque}
\addcontentsline{toc}{subparagraph}{Deque}

\subsubsection{Description}

\begin{itemize}
\tightlist
\item
  A \textbf{deque} is a linear data structure that allows insertion and
  deletion of elements from both the front and rear ends.
\item
  \textbf{Python Equivalent:} \texttt{collections.deque}
\end{itemize}

\subsubsection{Operations}

\begin{itemize}
\tightlist
\item
  \textbf{InsertFront:} \(O(1)\) --- Add an element to the front.
\item
  \textbf{InsertLast:} \(O(1)\) --- Add an element to the end.
\item
  \textbf{DeleteFront:} \(O(1)\) --- Remove an element from the front.
\item
  \textbf{DeleteLast:} \(O(1)\) --- Remove an element from the end.
\item
  \textbf{PeekFront:} \(O(1)\) --- View the front element.
\item
  \textbf{PeekLast:} \(O(1)\) --- View the last element.
\item
  \textbf{IsEmpty:} \(O(1)\) --- Check if the deque is empty.
\end{itemize}

\subsubsection{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Useful in scenarios requiring access from both ends, such as the
    implementation of both stacks and queues, task scheduling, and
    sliding window algorithms.
  \end{itemize}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Hash Table}\vspace{3mm}

\subparagraph*{Descriptions}\label{descriptions}
\addcontentsline{toc}{subparagraph}{Descriptions}

\begin{itemize}
\tightlist
\item
  A hash table is a data structure that maps keys to values using a hash
  function, which transforms the key into an index in an array.
\item
  \textbf{Python Equivalent:} \texttt{dict}
\end{itemize}

\subparagraph*{Operations}\label{operations-6}
\addcontentsline{toc}{subparagraph}{Operations}

\begin{itemize}
\tightlist
\item
  \textbf{Insert:} \(O(1)\) --- Map a key to a value by computing its
  hash.
\item
  \textbf{Search:} \(O(1)\) --- Retrieve the value associated with a
  given key.
\item
  \textbf{Delete:} \(O(1)\) --- Remove the key-value pair from the
  table.
\end{itemize}

\subparagraph*{Usage}\label{usage-22}
\addcontentsline{toc}{subparagraph}{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Highly efficient for scenarios requiring fast lookups, such as
    databases, caches, and dictionaries.
  \end{itemize}
\end{itemize}

\subparagraph*{Collisions}\label{collisions}
\addcontentsline{toc}{subparagraph}{Collisions}

\begin{itemize}
\item
  \textbf{Handling Collisions:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Chaining:} Store multiple elements at the same index using a
    linked list.
  \item
    \textbf{Open Addressing (Probing):} Find another open slot using
    techniques like linear probing, quadratic probing, or double
    hashing.
  \end{itemize}
\end{itemize}

\subparagraph*{Hashing}\label{hashing}
\addcontentsline{toc}{subparagraph}{Hashing}

\begin{itemize}
\item
  \textbf{Hashing}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Hashing} is the process of mapping keys to indices in an
    array using a hash function. It ensures efficient data retrieval by
    minimizing the number of comparisons required.
  \end{itemize}
\end{itemize}

\textbf{Hash Function} - A \textbf{hash function} is a function that
converts input \emph{(key)} into a fixed-size value, typically an
integer, which serves as an index in the hash table array. - A good hash
function has the following properties:

\begin{verbatim}
  - **Deterministic:** The same key always produces the same hash value.
  - **Uniform Distribution:** The hash values should be distributed uniformly across the array to minimize collisions.
  - **Fast Computation:** The function should be quick to compute.
\end{verbatim}

\begin{itemize}
\item
  \textbf{Hash Keys}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Hash Key:} The key for which the hash function generates an
    index.
  \item
    \textbf{Hash Value:} The integer index produced by the hash
    function.
  \end{itemize}
\end{itemize}

\subparagraph*{\texorpdfstring{\textbf{How to perform hash function on
calculator}}{How to perform hash function on calculator}}\label{how-to-perform-hash-function-on-calculator}
\addcontentsline{toc}{subparagraph}{\textbf{How to perform hash function
on calculator}}

To determine where the data associated with the last 4 digits of the
Social Security number \emph{(`2023')} will be stored in the array,
follow these steps:

\textbf{1.} Understand the Hash Function: The problem specifies a hash
function given by key \% 1009. Here, \% denotes the modulus operation.
This operation returns the remainder of the division of key by 1009.

\textbf{2.} Determine the Key: The last 4 digits of the Social Security
number are `2023'. Therefore, the key you're interested in is 2023.

\textbf{3.} Apply the Hash Function: Use the hash function to find the
index in the array where the data should be stored. Specifically, you
need to compute:

\begin{verbatim}
a. Key / Hash - (whole number in result) * Hash
  i. For this example
    1. $(2023 / 1009) = 2.004955401$
    2. $2.004955401 - 2 = 0.004955401$
    3. $0.004955401 * 1009 = 5$
\end{verbatim}

\textbf{4.} By calculating the remainder, you will find the index in the
array soc where the data associated with the key `2023' will be stored.

\begin{verbatim}
a. soc[5]
\end{verbatim}

\end{tcolorbox}

\paragraph*{Trees}\label{trees}
\addcontentsline{toc}{paragraph}{Trees}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Tree}\vspace{3mm}

\subparagraph*{Description}\label{description-6}
\addcontentsline{toc}{subparagraph}{Description}

\begin{itemize}
\tightlist
\item
  A \textbf{tree} is a hierarchical data structure composed of nodes,
  where each node contains a value and references to child nodes. The
  top node is called the root, and nodes with no children are called
  leaves.
\item
  \textbf{Python Equivalent:} Custom class with \texttt{Node} and
  \texttt{Tree} classes
\end{itemize}

\subparagraph*{Types}\label{types-1}
\addcontentsline{toc}{subparagraph}{Types}

\begin{itemize}
\tightlist
\item
  \textbf{Binary Tree:} Each node has at most two children \emph{(left
  and right)}.
\item
  \textbf{Binary Search Tree (BST):} A binary tree where the left child
  contains values less than the parent, and the right child contains
  values greater than the parent.
\item
  \textbf{AVL Tree:} A self-balancing binary search tree.
\item
  \textbf{Red-Black Tree:} Another type of self-balancing binary search
  tree.
\item
  \textbf{B-Tree:} A self-balancing tree that maintains sorted data and
  allows searches, sequential access, insertions, and deletions in
  logarithmic time.
\end{itemize}

\subparagraph*{Forms}\label{forms}
\addcontentsline{toc}{subparagraph}{Forms}

\begin{itemize}
\tightlist
\item
  \textbf{Full Binary Tree} --- Definition: A binary tree in which every
  node has either 0 or 2 children.
\item
  \textbf{Complete Binary Tree} --- Definition: A binary tree in which
  all levels are completely filled except possibly the last level, which
  is filled from left to right.
\item
  \textbf{Perfect Binary Tree} --- Definition: A binary tree in which
  all interior nodes have two children and all leaves are at the same
  level.
\item
  \textbf{Balanced Binary Tree} --- Definition: A binary tree where the
  height of the left and right subtrees of any node differ by at most
  one.
\end{itemize}

\subparagraph*{Operations}\label{operations-7}
\addcontentsline{toc}{subparagraph}{Operations}

\begin{itemize}
\item
  \textbf{Insertion:} \(\text{O(log ‚Å°n)}\) for balanced trees like AVL or
  Red-Black Trees; \(O(n)\) for unbalanced trees.
\item
  \textbf{Deletion:} \(\text{O(log ‚Å°n)}\) for balanced trees; \(O(n)\)
  for unbalanced trees.

  \begin{itemize}
  \tightlist
  \item
    \textbf{BST:} Find the node to be removed, then:

    \begin{itemize}
    \tightlist
    \item
      \textbf{No Children:} Just remove the node.
    \item
      \textbf{One Child:} Bypass the node and link its parent directly
      to its child.
    \item
      \textbf{Two Children:} Find the in-order predecessor \emph{(or
      successor)}, swap values, and remove the predecessor \emph{(or
      successor)} node.
    \item
      \textbf{Time Complexity:} \(\text{O(log n)}\) on average, \(O(n)\)
      in the worst case.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Search:} \(\text{O(log ‚Å°n)}\) for balanced trees; \(O(n)\) for
  unbalanced trees.
\item
  \textbf{Traversal:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{In-order:} \(O(n)\) --- Left, Root, Right \emph{(used in
    BSTs to get sorted order)}.
  \item
    \textbf{Pre-order:} \(O(n)\) --- Root, Left, Right.
  \item
    \textbf{Post-order:} \(O(n)\) --- Left, Right, Root.
  \item
    \textbf{Level-order:} \(O(n)\)--- Traverse nodes level by level.
  \end{itemize}
\end{itemize}

\subparagraph*{Usage}\label{usage-23}
\addcontentsline{toc}{subparagraph}{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Suitable for hierarchical data \emph{(like file systems)}, database
    indexing, and scenarios requiring sorted data with dynamic insertion
    and deletion.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\subparagraph*{Adelson-Velsky and Landis
Trees}\label{adelson-velsky-and-landis-trees}
\addcontentsline{toc}{subparagraph}{Adelson-Velsky and Landis Trees}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{AVL Trees}\vspace{3mm}

\subparagraph*{Properties}\label{properties}
\addcontentsline{toc}{subparagraph}{Properties}

\begin{itemize}
\tightlist
\item
  An AVL tree is a binary search tree in which the height of the two
  child subtrees of any node differs by at most one.
\item
  If at any time during insertion or deletion this condition is
  violated, the tree is rebalanced through rotations.
\end{itemize}

\subparagraph*{Balancing}\label{balancing}
\addcontentsline{toc}{subparagraph}{Balancing}

\begin{itemize}
\tightlist
\item
  \textbf{Single Rotation:} Used when a node is inserted into the left
  subtree of the \textbf{left child} or the \texttt{right\ subtree} of
  the \textbf{right child}.
\item
  \textbf{Double Rotation:} Used when a node is inserted into the left
  subtree of the right child or the \texttt{right\ subtree} of the
  \textbf{left child}.
\end{itemize}

\subparagraph*{Time}\label{time}
\addcontentsline{toc}{subparagraph}{Time}

\begin{itemize}
\item
  \textbf{Time Complexity:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Search}, \textbf{Insertion}, \textbf{Deletion:}
    \(\text{O(log n)}\), where n is the number of nodes.
  \end{itemize}
\end{itemize}

\subparagraph*{Usage}\label{usage-24}
\addcontentsline{toc}{subparagraph}{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    AVL trees are well-suited for applications where frequent insertions
    and deletions occur, and maintaining strict balance is important.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\subparagraph*{Red-Black}\label{red-black}
\addcontentsline{toc}{subparagraph}{Red-Black}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Red-Black Trees}\vspace{3mm}

\subparagraph*{Properties}\label{properties-1}
\addcontentsline{toc}{subparagraph}{Properties}

\begin{itemize}
\item
  A Red-Black tree is a binary search tree with an extra bit of storage
  per node: its color, which can be either red or black.
\item
  The tree satisfies several properties:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Every node is either red or black.
  \item
    The root is always black.
  \item
    All leaves (NIL nodes) are black.
  \item
    Red nodes cannot have red children \emph{(no two red nodes can be
    adjacent)}.
  \item
    Every path from a node to its descendant NIL nodes must have the
    same number of black nodes \emph{(black height)}.
  \end{enumerate}
\end{itemize}

\subparagraph*{Balancing}\label{balancing-1}
\addcontentsline{toc}{subparagraph}{Balancing}

\begin{itemize}
\tightlist
\item
  The tree is kept balanced by performing rotations and color changes
  during insertions and deletions.
\end{itemize}

\subparagraph*{Time}\label{time-1}
\addcontentsline{toc}{subparagraph}{Time}

\begin{itemize}
\item
  \textbf{Time Complexity:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Search}, \textbf{Insertion}, \textbf{Deletion:}
    \(\text{O(log n)}\).
  \end{itemize}
\end{itemize}

\subparagraph*{Usage}\label{usage-25}
\addcontentsline{toc}{subparagraph}{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    Red-Black trees are used in many systems, such as the Linux kernel's
    process scheduling and in standard libraries like C++'s
    \textbf{std::map} and \textbf{std::set}, due to their relatively
    simple implementation and good performance.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\subparagraph*{Balanced Tree}\label{balanced-tree}
\addcontentsline{toc}{subparagraph}{Balanced Tree}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{B-Trees}\vspace{3mm}

\subparagraph*{Properties}\label{properties-2}
\addcontentsline{toc}{subparagraph}{Properties}

\begin{itemize}
\tightlist
\item
  A B-tree is a self-balancing search tree in which nodes can have more
  than two children. It's commonly used in databases and file systems.
\item
  A B-tree of order \texttt{m} can have at most \texttt{m-1} keys and
  \texttt{m} children.
\item
  All leaf nodes are at the same depth, and internal nodes act as a
  guide to direct searches.
\end{itemize}

\subparagraph*{Balancing}\label{balancing-2}
\addcontentsline{toc}{subparagraph}{Balancing}

\begin{itemize}
\tightlist
\item
  Balancing in B-trees is achieved through splitting and merging nodes.
\item
  When a node in a B-tree becomes too full \emph{(i.e., has more than
  m-1 keys)}, it is split into two nodes, and the middle key is pushed
  up to the parent node.
\item
  When a node has too few keys, it may borrow keys from its neighbors or
  merge with a neighboring node.
\end{itemize}

\subparagraph*{Time}\label{time-2}
\addcontentsline{toc}{subparagraph}{Time}

\begin{itemize}
\item
  \textbf{Time Complexity:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Search}, \textbf{Insertion}, \textbf{Deletion:}
    \(\text{O(log n)}\).
  \end{itemize}
\end{itemize}

\subparagraph*{Usage}\label{usage-26}
\addcontentsline{toc}{subparagraph}{Usage}

\begin{itemize}
\item
  \textbf{Use Cases:}

  \begin{itemize}
  \tightlist
  \item
    B-trees are particularly effective for systems that read and write
    large blocks of data, such as databases and file systems, where
    minimizing disk I/O operations is critical.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Wrap-up}}{Wrap-up}}\label{wrap-up}
\addcontentsline{toc}{subparagraph}{\textbf{Wrap-up}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Comparison Summary}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{AVL Trees:} Strictly balanced, more rotations, better for
  search-heavy applications.
\item
  \textbf{Red-Black Trees:} Looser balancing, fewer rotations, generally
  faster insertions and deletions.
\item
  \textbf{B-Trees:} Optimized for storage systems, used in databases,
  and file systems for handling large volumes of data.
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Tree Traversal}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \emph{Pre-Order Traversal (NLR)} - Node, Left, Right
\item
  \emph{In-Order Traversal (LNR)} - Left, Node, Right
\item
  \emph{Post-Order Traversal (LRN)} - Left, Right, Node
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{Pre-Order Traversal (NLR)}\label{pre-order-traversal-nlr}
\addcontentsline{toc}{subparagraph}{Pre-Order Traversal (NLR)}

\section{Order:}

\textbf{N}ode ‚Üí \textbf{L}eft ‚Üí \textbf{R}ight

\section{Process:}

\begin{itemize}
\tightlist
\item
  Visit the \textbf{Node} first.
\item
  Then recursively visit the \textbf{Left} subtree.
\item
  Finally, visit the \textbf{Right} subtree.
\end{itemize}

\section{Examples:}

If you have a tree like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    A}
\NormalTok{   / \textbackslash{}}
\NormalTok{  B   C}
\NormalTok{ / \textbackslash{}}
\NormalTok{D   E}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The Pre-Order traversal would be: \textbf{A B D E C}
\end{itemize}

\subparagraph*{In-Order Traversal (LNR)}\label{in-order-traversal-lnr}
\addcontentsline{toc}{subparagraph}{In-Order Traversal (LNR)}

\section{Order:}

\textbf{L}eft ‚Üí \textbf{N}ode ‚Üí \textbf{R}ight

\section{Process:}

\begin{itemize}
\tightlist
\item
  Recursively visit the \textbf{Left} subtree.
\item
  Then visit the \textbf{Node}.
\item
  Finally, visit the \textbf{Right} subtree.
\end{itemize}

\section{Example:}

For the same tree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    A}
\NormalTok{   / \textbackslash{}}
\NormalTok{  B   C}
\NormalTok{ / \textbackslash{}}
\NormalTok{D   E}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The In-Order traversal would be: \textbf{D B E A C}
\end{itemize}

\subparagraph*{Post-Order Traversal
(LRN)}\label{post-order-traversal-lrn}
\addcontentsline{toc}{subparagraph}{Post-Order Traversal (LRN)}

\section{Order:}

\textbf{L}eft ‚Üí \textbf{R}ight ‚Üí \textbf{N}ode

\section{Process:}

\begin{itemize}
\tightlist
\item
  Recursively visit the \textbf{Left} subtree.
\item
  Then visit the \textbf{Right} subtree.
\item
  Finally, visit the \textbf{Node}.
\end{itemize}

\section{Examples:}

For the same tree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    A}
\NormalTok{   / \textbackslash{}}
\NormalTok{  B   C}
\NormalTok{ / \textbackslash{}}
\NormalTok{D   E}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The Post-Order traversal would be: \textbf{D E B C A}
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Wrap-up}}{Wrap-up}}\label{wrap-up-1}
\addcontentsline{toc}{subparagraph}{\textbf{Wrap-up}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{How to Remember Them:}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Pre-Order (NLR):} Think of ``Pre'' as ``before'' - you process
  the Node before anything else.
\item
  \textbf{In-Order (LNR):} ``In'' implies ``in between'' - the Node is
  processed in between the Left and Right subtrees.
\item
  \textbf{Post-Order (LRN):} ``Post'' means ``after'' - the Node is
  processed after the subtrees.
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Visual Mnemonic:}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Pre-Order:} Imagine starting at the root and touching it
  first.
\item
  \textbf{In-Order:} Imagine walking along the edge of the tree,
  touching the left side first, then the root, and then the right side.
\item
  \textbf{Post-Order:} Imagine leaving the tree by processing the
  children before the root.
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{Heap}\label{heap}
\addcontentsline{toc}{paragraph}{Heap}

\section{Description:}

\begin{itemize}
\tightlist
\item
  A \textbf{heap} is a specialized tree-based data structure that
  satisfies the heap property. In a \textbf{max-heap}, the parent node
  is always greater than or equal to its children; in a
  \textbf{min-heap}, the parent node is always less than or equal to its
  children.
\item
  \textbf{Python Equivalent:} \texttt{heapq} \emph{(min-heap by
  default)}
\end{itemize}

\section{Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Insert:} \(\text{O(log ‚Å°n)}\) --- Add a new element and adjust
  the heap to maintain the heap property.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Add the Element at the End:}

    \begin{itemize}
    \tightlist
    \item
      Insert the new element at the end of the heap \emph{(i.e., the
      next available leaf node)}.
    \end{itemize}
  \item
    \textbf{Heapify Up (Percolate Up):}

    \begin{itemize}
    \tightlist
    \item
      Compare the inserted element with its parent node.
    \item
      If the heap property \emph{(Min-Heap or Max-Heap)} is violated
      \emph{(e.g., in a Min-Heap, if the new element is smaller than its
      parent)}, swap the element with its parent.
    \item
      Repeat the process until the heap property is restored or the
      element becomes the root.
    \end{itemize}
  \end{itemize}
\item
  \textbf{DeleteMax/Min:} \(\text{O(log ‚Å°n)}\) --- Remove the root
  \emph{(max or min)} and adjust the heap.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Remove the Root Element:}

    \begin{itemize}
    \tightlist
    \item
      The root element of the heap \emph{(the smallest element in a
      Min-Heap or the largest in a Max-Heap)} is removed. This is
      because the root element has the highest priority.
    \end{itemize}
  \item
    \textbf{Replace the Root with the Last Element:}

    \begin{itemize}
    \tightlist
    \item
      Move the last element in the heap \emph{(the rightmost leaf node)}
      to the root position.
    \end{itemize}
  \item
    \textbf{Heapify Down (Percolate Down):}

    \begin{itemize}
    \tightlist
    \item
      Compare the new root element with its children.
    \item
      If the heap property is violated \emph{(e.g., in a Min-Heap, if
      the root is greater than any of its children)}, swap the root with
      the smallest child \emph{(in a Max-Heap, swap with the largest
      child)}.
    \item
      Repeat the process down the tree until the heap property is
      restored.
    \end{itemize}
  \end{itemize}
\item
  \textbf{PeekMax/Min:} \(O(1)\) --- Access the root element.
\item
  \textbf{Heapify:} \(O(n)\) --- Convert an unsorted array into a heap.
\end{itemize}

\section{Use Cases:}

\begin{itemize}
\tightlist
\item
  Often used to implement priority queues, scheduling algorithms, and
  for efficient sorting \emph{(Heap Sort)}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Steps To Figure Out The Index Of
Child Nodes in
Heaps}}{Steps To Figure Out The Index Of Child Nodes in Heaps}}\label{steps-to-figure-out-the-index-of-child-nodes-in-heaps}
\addcontentsline{toc}{subparagraph}{\textbf{Steps To Figure Out The
Index Of Child Nodes in Heaps}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{The Index Of The Right Child Of An Item In A Heap}\vspace{3mm}

\textbf{heapList = {[}22, 33, 44, 55, 66{]}}

\begin{itemize}
\tightlist
\item
  Identify the index of the item:

  \begin{itemize}
  \tightlist
  \item
    Find the index of the item 22 in the heap list. Let's call this
    index \(i\).
  \end{itemize}
\item
  Use the formula for the right child:

  \begin{itemize}
  \tightlist
  \item
    In a binary heap, if an element is at index \(i\), the index of its
    right child is given by the formula: \(2i + 2\).
  \end{itemize}
\item
  Apply the formula:

  \begin{itemize}
  \tightlist
  \item
    Substitute the value of \(i\) obtained from step 1 into the formula
    \(2i+2\).
  \end{itemize}
\item
  Verify the index:

  \begin{itemize}
  \tightlist
  \item
    Ensure the calculated index falls within the bounds of the heap
    list.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{The Index Of The Left Child Of An Item In A Heap}\vspace{3mm}

\textbf{heapList = {[}22, 33, 44, 55, 66{]}}

\begin{itemize}
\tightlist
\item
  Identify the index of the item:

  \begin{itemize}
  \tightlist
  \item
    Find the index of the item in the heap list. Let's call this index
    \(i\).
  \end{itemize}
\item
  Use the formula for the left child:

  \begin{itemize}
  \tightlist
  \item
    In a binary heap, if an element is at index \(i\), the index of its
    left child is given by the formula: \(2i+1\).
  \end{itemize}
\item
  Apply the formula:

  \begin{itemize}
  \tightlist
  \item
    Substitute the value of \(iii\) obtained from step 1 into the
    formula \(2i+1\).
  \end{itemize}
\item
  Verify the index:

  \begin{itemize}
  \tightlist
  \item
    Ensure the calculated index falls within the bounds of the heap
    list.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{Set}\label{set}
\addcontentsline{toc}{subparagraph}{Set}

\section{Description:}

\begin{itemize}
\tightlist
\item
  A \textbf{set} is an abstract data structure that stores unique
  elements, with no specific order. It supports operations that allow
  the management of unique collections of data.
\item
  \textbf{Python Equivalent:} \texttt{set}
\end{itemize}

\section{Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Insert:} \(O(1)\) on average --- Add a new element if it's not
  already present.
\item
  \textbf{Delete:} \(O(1)\) on average --- Remove an element if it
  exists.
\item
  \textbf{Search:} \(O(1)\) on average --- Check if an element is
  present in the set.
\item
  \textbf{Union:} \(O(n)\) --- Combine elements from two sets.
\item
  \textbf{Intersection:} \(O(n)\) --- Get common elements between two
  sets.
\item
  \textbf{Difference:} \(O(n)\) --- Get elements present in one set but
  not the other.
\end{itemize}

\section{Usage:}

\begin{itemize}
\tightlist
\item
  Useful in situations requiring the management of unique elements, such
  as maintaining a list of unique IDs, handling membership checks, and
  performing mathematical set operations.
\end{itemize}

\subparagraph*{Graph}\label{graph}
\addcontentsline{toc}{subparagraph}{Graph}

\section{Description:}

\begin{itemize}
\tightlist
\item
  A \textbf{graph} is a collection of nodes \emph{(vertices)} connected
  by edges. Graphs can be \textbf{directed} \emph{(edges have a
  direction)} or \textbf{undirected} \emph{(edges do not have a
  direction)}.
\item
  \textbf{Python Equivalent:} \texttt{dict} of lists,
  \texttt{collections.defaultdict}, or custom class
\end{itemize}

\section{Types:}

\begin{itemize}
\tightlist
\item
  \textbf{Directed Graph (Digraph):} All edges have a direction.
\item
  \textbf{Undirected Graph:} Edges do not have direction.
\item
  \textbf{Weighted Graph:} Edges have weights representing costs or
  distances.
\item
  \textbf{Unweighted Graph:} Edges have no weights.
\end{itemize}

\section{Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Add Vertex:} \(O(1)\) --- Add a new node.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Vertex:} Simply add the vertex to the vertex set.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\).
    \end{itemize}
  \end{itemize}
\item
  \textbf{Add Edge:} \(O(1)\) --- Add a connection between two nodes.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Edge:} Add an edge by connecting two vertices, updating
    adjacency lists or matrices.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\) for adjacency list, \(O(1)\)
      for adjacency matrix.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Remove Vertex:} \(O(V+E)\) --- Remove a node and its
  associated edges.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Vertex:} Remove the vertex and all associated edges.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(\text{O(V + E)}\) in an adjacency
      list, \(O(V^2)\) in an adjacency matrix, where V is the number of
      vertices and E is the number of edges.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Remove Edge:} \(O(1)\) --- Remove a connection between two
  nodes.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Edge:} Remove the edge between two vertices.

    \begin{itemize}
    \tightlist
    \item
      \textbf{Time Complexity:} \(O(1)\) for adjacency list, \(O(1)\)
      for adjacency matrix.
    \end{itemize}
  \end{itemize}
\item
  \textbf{Search:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Depth-First Search (DFS):} \(O(V+E)\) --- Explore as far as
    possible along each branch before backtracking.
  \item
    \textbf{Breadth-First Search (BFS):} \(O(V+E)\)--- Explore all
    neighbors of a node before moving to the next level.
  \end{itemize}
\end{itemize}

\section{Usage:}

\begin{itemize}
\tightlist
\item
  Ideal for modeling relationships and connections, such as social
  networks, transportation networks, and dependency graphs in project
  management.
\end{itemize}

\paragraph*{Path Algorithms}\label{path-algorithms}
\addcontentsline{toc}{paragraph}{Path Algorithms}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Dijkstra's Shortest Path Algorithm}\vspace{3mm}

\begin{itemize}
\item
  \textbf{Overview:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Type:} Greedy algorithm.
  \item
    \textbf{Applicability:} Works on graphs with non-negative edge
    weights.
  \item
    \textbf{Time Complexity:} \(O(V2)\) for the simplest implementation,
    \(\text{O(V log V+E)}\) with a priority queue \emph{(using a binary
    heap)}, where \(V\) is the number of vertices and \(E\) is the
    number of edges.
  \item
    \textbf{Functionality:} It finds the shortest path from a single
    source vertex to all other vertices in a graph by iteratively
    selecting the vertex with the smallest known distance, updating the
    distances to its neighbors, and marking it as visited.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Bellman-Ford Shortest Path Algorithm}\vspace{3mm}

\begin{itemize}
\item
  \textbf{Overview:}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Type:} Dynamic programming algorithm.
  \item
    \textbf{Applicability:} Works on graphs with negative edge weights
    and can detect negative weight cycles.
  \item
    \textbf{Time Complexity:} \(O(V*E)\), where \(V\) is the number of
    vertices and \(E\) is the number of edges.
  \item
    \textbf{Functionality:} It calculates the shortest path from a
    single source vertex to all other vertices by relaxing all edges
    repeatedly over \(V‚àí1\) iterations.
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Differences Between Dijkstra and Bellman-Ford}\vspace{3mm}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2717}}
  >{\raggedleft\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4130}}
  >{\centering\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3152}}@{}}
\caption{Comparison chart}\tabularnewline
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature Dijkstra's
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Algorithm Bellman-Ford
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Algorithm
\end{minipage} \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature Dijkstra's
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedleft
Algorithm Bellman-Ford
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Algorithm
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Edge Weights & Non-negative edge weights only & Handles negative edge
weights \\
Negative Cycle Detection & Cannot detect negative cycles & Can detect
negative cycles \\
Time Complexity & \(O(V2)\) for the simplest implementation,
\(\text{O(V log V+E)}\) with a priority queue \emph{(using a binary
heap)}, where \(V\) is the number of vertices and E is the number of
edges. & \(O(V*E)\), where \(V\) is the number of vertices and \(E\) is
the number of edges. \\
Graph Type & Directed or undirected with non-negative weights & Directed
or undirected with any weights, including negative \\
Algorithm Type & Greedy & Dynamic programming \\
Use Case & Faster for graphs with non-negative weights & More general,
can be used when negative weights are present \\
\end{longtable}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Summary}}{Summary}}\label{summary-1}
\addcontentsline{toc}{subparagraph}{\textbf{Summary}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Summary of ADTs}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Array:} Fixed-size, contiguous memory; fast access by index.
\item
  \textbf{Linked List:} Dynamic size; efficient insertions and
  deletions.
\item
  \textbf{Stack:} LIFO order; used in recursion, undo operations.
\item
  \textbf{Queue:} FIFO order; used in scheduling, buffering.
\item
  \textbf{Deque:} Double-ended queue; flexible insertions/deletions.
\item
  \textbf{Hash Table:} Key-value pairs; fast lookups and inserts.
\item
  \textbf{Tree:} Hierarchical structure; efficient searches and sorted
  data.
\item
  \textbf{Heap:} Binary tree for priority queues; fast access to
  max/min.
\item
  \textbf{Set:} Unique elements; fast membership checks.
\item
  \textbf{Graph:} Nodes and edges; used in networks and relationship
  modeling.
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\paragraph*{Key Operations in a
Dictionary/Map}\label{key-operations-in-a-dictionarymap}
\addcontentsline{toc}{paragraph}{Key Operations in a Dictionary/Map}

A \textbf{Dictionary} (in Python) or \textbf{Map} (in many other
programming languages) is a data structure that stores key-value pairs,
where each unique key maps to a specific value. Dictionaries/Maps
provide efficient insertion, deletion, and lookup operations, typically
in \(O(1)\) time on average due to the underlying hash table
implementation.

\subparagraph*{Insertion}\label{insertion}
\addcontentsline{toc}{subparagraph}{Insertion}

Description: Adding a new key-value pair to the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionary[key] = value}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phone\_book = \{\}}
\NormalTok{phone\_book[\textquotesingle{}Alice\textquotesingle{}] = \textquotesingle{}555{-}1234\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

This adds the key \texttt{\textquotesingle{}Alice\textquotesingle{}}
with the value \texttt{\textquotesingle{}555-1234\textquotesingle{}} to
the \texttt{phone\_book} dictionary.

\subparagraph*{Lookup (Access)}\label{lookup-access}
\addcontentsline{toc}{subparagraph}{Lookup (Access)}

Description: Retrieving the value associated with a given key.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value = dictionary[key]}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice\_number = phone\_book[\textquotesingle{}Alice\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

This retrieves the value associated with
\texttt{\textquotesingle{}Alice\textquotesingle{}}, which is
\texttt{\textquotesingle{}555-1234\textquotesingle{}}.

\subparagraph*{Deletion}\label{deletion}
\addcontentsline{toc}{subparagraph}{Deletion}

Description: Removing a key-value pair from the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{del dictionary[key]}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{del phone\_book[\textquotesingle{}Alice\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

This removes the \texttt{\textquotesingle{}Alice\textquotesingle{}}
entry from the \texttt{phone\_book} dictionary.

\subparagraph*{Update}\label{update}
\addcontentsline{toc}{subparagraph}{Update}

Description: Updating the value associated with a given key.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionary[key] = new\_value}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phone\_book[\textquotesingle{}Alice\textquotesingle{}] = \textquotesingle{}555{-}5678\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

This updates \texttt{\textquotesingle{}Alice\textquotesingle{}s} number
to \texttt{\textquotesingle{}555-5678\textquotesingle{}}.

\subparagraph*{Check Existence}\label{check-existence}
\addcontentsline{toc}{subparagraph}{Check Existence}

Description: Checking if a key exists in the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{key in dictionary}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{if \textquotesingle{}Alice\textquotesingle{} in phone\_book:}
\NormalTok{    print("Alice is in the phone book")}
\end{Highlighting}
\end{Shaded}

This checks if \texttt{\textquotesingle{}Alice\textquotesingle{}} is a
key in \texttt{phone\_book}.

\subparagraph*{Iteration}\label{iteration}
\addcontentsline{toc}{subparagraph}{Iteration}

Description: Iterating over keys, values, or key-value pairs in the
dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Iterate over keys}
\NormalTok{for key in dictionary:}
\NormalTok{    print(key)}
\end{Highlighting}
\end{Shaded}

Iterate over values

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{for value in dictionary.values():}
\NormalTok{    print(value)}
\end{Highlighting}
\end{Shaded}

Iterate over key-value pairs

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{for key, value in dictionary.items():}
\NormalTok{    print(f"\{key\}: \{value\}")}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{for name, number in phone\_book.items():}
\NormalTok{    print(f"\{name\}: \{number\}")}
\end{Highlighting}
\end{Shaded}

This prints all key-value pairs in \texttt{phone\_book}.

\subparagraph*{Get Method}\label{get-method}
\addcontentsline{toc}{subparagraph}{Get Method}

Description: Retrieving the value associated with a given key, with an
optional default if the key doesn't exist.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value = dictionary.get(key, default\_value)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bob\_number = phone\_book.get(\textquotesingle{}Bob\textquotesingle{}, \textquotesingle{}Not Found\textquotesingle{})}
\end{Highlighting}
\end{Shaded}

If \texttt{\textquotesingle{}Bob\textquotesingle{}} is not in
\texttt{phone\_book}, \texttt{bob\_number} will be
\texttt{\textquotesingle{}Not\ Found\textquotesingle{}}.

\subparagraph*{Length}\label{length}
\addcontentsline{toc}{subparagraph}{Length}

Description: Getting the number of key-value pairs in the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{length = len(dictionary)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num\_contacts = len(phone\_book)}
\end{Highlighting}
\end{Shaded}

This returns the number of entries in \texttt{phone\_book}.

\subparagraph*{Clearing}\label{clearing}
\addcontentsline{toc}{subparagraph}{Clearing}

Description: Removing all key-value pairs from the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionary.clear()}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phone\_book.clear()}
\end{Highlighting}
\end{Shaded}

This removes all entries from \texttt{phone\_book}, making it an empty
dictionary.

\subparagraph*{Copying}\label{copying}
\addcontentsline{toc}{subparagraph}{Copying}

Description: Creating a shallow copy of the dictionary.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_dictionary = dictionary.copy()}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{backup\_phone\_book = phone\_book.copy()}
\end{Highlighting}
\end{Shaded}

This creates a copy of \texttt{phone\_book} called
\texttt{backup\_phone\_book}.

\subparagraph*{Pop}\label{pop}
\addcontentsline{toc}{subparagraph}{Pop}

Description: Removing a key from the dictionary and returning its value.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value = dictionary.pop(key, default\_value)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{removed\_number = phone\_book.pop(\textquotesingle{}Alice\textquotesingle{}, \textquotesingle{}Not Found\textquotesingle{})}
\end{Highlighting}
\end{Shaded}

Removes \texttt{\textquotesingle{}Alice\textquotesingle{}} from
\texttt{phone\_book} and returns her number. If
\texttt{\textquotesingle{}Alice\textquotesingle{}} is not found, it
returns \texttt{\textquotesingle{}Not\ Found\textquotesingle{}}.

\subparagraph*{Popitem}\label{popitem}
\addcontentsline{toc}{subparagraph}{Popitem}

Description: Removes and returns an arbitrary key-value pair as a tuple
\emph{(key, value)}.

Syntax

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{key, value = dictionary.popitem()}
\end{Highlighting}
\end{Shaded}

Example

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{last\_entry = phone\_book.popitem()}
\end{Highlighting}
\end{Shaded}

Removes and returns the last inserted key-value pair in the dictionary.

\subparagraph*{Setdefault}\label{setdefault}
\addcontentsline{toc}{subparagraph}{Setdefault}

Description: Returns the value of a key if it exists; otherwise, inserts
the key with a specified value and returns that value.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value = dictionary.setdefault(key, default\_value)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice\_number = phone\_book.setdefault(\textquotesingle{}Alice\textquotesingle{}, \textquotesingle{}555{-}0000\textquotesingle{})}
\end{Highlighting}
\end{Shaded}

If \texttt{\textquotesingle{}Alice\textquotesingle{}} is in
\texttt{phone\_book}, it returns her number. Otherwise, it adds
\texttt{\textquotesingle{}Alice\textquotesingle{}:\ \textquotesingle{}555-0000\textquotesingle{}}
to phone\_book and returns
\texttt{\textquotesingle{}555-0000\textquotesingle{}}.

\section*{Applies Algorithms - (40\%)}\label{applies-algorithms---40}
\addcontentsline{toc}{section}{Applies Algorithms - (40\%)}

\markright{Applies Algorithms - (40\%)}

Variable declaration \textbf{(dynamic vs static)}

The way variables are declared and managed in programming languages can
be broadly categorized into \textbf{static} and \textbf{dynamic} types.
This classification impacts how and when variables are allocated and
accessed in memory.

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Static Variable Declaration}\vspace{3mm}

\subparagraph*{Description}\label{description-10}
\addcontentsline{toc}{subparagraph}{Description}

\begin{itemize}
\tightlist
\item
  \textbf{Static} variables are allocated memory at compile time, and
  their type and size are known before the program runs. The memory for
  static variables is typically allocated on the stack or in the data
  segment of memory.
\end{itemize}

\subparagraph*{Characteristics}\label{characteristics}
\addcontentsline{toc}{subparagraph}{Characteristics}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Fixed Size:} The size and type of the variable are determined
  at compile time.
\item
  \textbf{Memory Allocation:} Memory is allocated during compilation and
  deallocated when the program exits or the variable goes out of scope.
\item
  \textbf{Scope and Lifetime:} - \textbf{Scope:} The scope
  \emph{(visibility)} of static variables is determined by where they
  are declared \emph{(e.g., within a function or globally)}. -
  \textbf{Lifetime:} The variable's lifetime extends for the duration of
  the program or the block in which it is declared.
\end{enumerate}

\subparagraph*{Examples}\label{examples-6}
\addcontentsline{toc}{subparagraph}{Examples}

\textbf{C/C++:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// Static variable}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{x} is a static variable with a fixed size and type,
determined at compile time.

\textbf{Java:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ Example \{}
    \KeywordTok{static}\NormalTok{ int x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// Static class variable}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In Java, \texttt{x} is a static variable of the class \texttt{Example},
meaning it belongs to the class rather than any specific instance.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Dynamic Variable Declaration}\vspace{3mm}

\subparagraph*{Description}\label{description-11}
\addcontentsline{toc}{subparagraph}{Description}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic} variables are allocated memory at runtime. Their type
  and size are determined while the program is executing, and they are
  often managed using dynamic memory allocation functions or constructs.
\end{itemize}

\subparagraph*{Characteristics}\label{characteristics-1}
\addcontentsline{toc}{subparagraph}{Characteristics}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Flexible Size:} The size and type of the variable can be
  determined and adjusted at runtime.
\item
  \textbf{Memory Allocation:} Memory is allocated on the heap or through
  dynamic memory management constructs, and deallocated when no longer
  needed.
\item
  \textbf{Scope and Lifetime:} - \textbf{Scope:} The scope of dynamic
  variables is determined by how they are referenced in the code. -
  \textbf{Lifetime:} The lifetime of a dynamic variable extends from the
  point of allocation to the point of deallocation.
\end{enumerate}

\subparagraph*{Examples}\label{examples-7}
\addcontentsline{toc}{subparagraph}{Examples}

\textbf{C/C++:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\OperatorTok{*}\NormalTok{ ptr }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));} \CommentTok{// Dynamic memory allocation}
\OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(}\NormalTok{ptr}\OperatorTok{);} \CommentTok{// Deallocate memory}
\end{Highlighting}
\end{Shaded}

\textbf{Python:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{]  }\CommentTok{\# Dynamic variable (list with one element)}
\FunctionTok{x.append}\NormalTok{(}\DecValTok{20}\NormalTok{)  }\CommentTok{\# Modify the list}
\end{Highlighting}
\end{Shaded}

In Python, \texttt{x} can dynamically grow in size as new elements are
added to the list.

\end{tcolorbox}

\subsubsection*{Strongly-typed vs
Weakly-typed}\label{strongly-typed-vs-weakly-typed}
\addcontentsline{toc}{subsubsection}{Strongly-typed vs Weakly-typed}

\paragraph*{Strongly-Typed Languages}\label{strongly-typed-languages}
\addcontentsline{toc}{paragraph}{Strongly-Typed Languages}

\section{Definition:}

In strongly-typed languages, the type of a variable is strictly
enforced. This means that once a variable is assigned a specific type,
it cannot be implicitly converted to another type without explicit
conversion.

\section{Key Characteristics:}

\begin{itemize}
\tightlist
\item
  \textbf{Strict Type Enforcement:} Operations between incompatible
  types will result in a compile-time or runtime error. For example, you
  cannot add a string to an integer without explicitly converting one of
  them.
\item
  \textbf{Fewer Implicit Conversions:} Strongly-typed languages avoid
  automatic type coercion, where one type is automatically converted to
  another.
\item
  \textbf{Type Safety:} The language provides more safety by catching
  type-related errors early, often at compile time.
\end{itemize}

\section{Examples:}

\begin{itemize}
\tightlist
\item
  \textbf{Java:} You cannot assign a string to an integer variable
  without explicit conversion.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \StringTok{"5"}\OperatorTok{;} \CommentTok{// Compile{-}time error}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{C\#:} You must explicitly cast types when necessary.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{string y }\OperatorTok{=} \StringTok{"5"}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DataTypeTok{int}\OperatorTok{.}\NormalTok{Parse}\OperatorTok{(}\NormalTok{y}\OperatorTok{);} \CommentTok{// Correct}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Python:} While dynamically typed, Python is strongly-typed as
  it does not allow implicit conversion between incompatible types.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{10}
\NormalTok{y }\OperatorTok{=} \StringTok{"5"}
\NormalTok{result }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y  }\CommentTok{\# Runtime error}
\end{Highlighting}
\end{Shaded}

\paragraph*{Weakly-typed Languages}\label{weakly-typed-languages}
\addcontentsline{toc}{paragraph}{Weakly-typed Languages}

\section{Definition:}

In weakly-typed languages, the type system is more flexible, allowing
implicit conversions between types. The language may automatically
convert one type to another as needed, often during runtime.

\section{Key Characteristics:}

\begin{itemize}
\tightlist
\item
  \textbf{Implicit Type Coercion:} The language can automatically
  convert types in certain situations, such as adding a number to a
  string by converting the number to a string.
\item
  \textbf{Less Type Safety:} While more flexible, weakly-typed languages
  may introduce subtle bugs due to unintended type coercions that go
  unnoticed.
\item
  \textbf{Ease of Use:} In some scenarios, weak typing can make code
  easier to write and understand, especially for quick scripting tasks.
\end{itemize}

\section{Examples:}

\begin{itemize}
\tightlist
\item
  \textbf{JavaScript:} Automatically converts types when needed.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ y }\OperatorTok{=} \StringTok{"5"}\OperatorTok{;}
\KeywordTok{let}\NormalTok{ result }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{;} \CommentTok{// "105" (y is converted to a string)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{PHP:} Also allows implicit type conversion.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{$x}\NormalTok{ = 10}\KeywordTok{;}
\VariableTok{$y}\NormalTok{ = }\StringTok{"5"}\KeywordTok{;}
\VariableTok{$result}\NormalTok{ = }\VariableTok{$x}\NormalTok{ + }\VariableTok{$y}\KeywordTok{;} \ExtensionTok{//}\NormalTok{ 15 }\ErrorTok{(}\ExtensionTok{y}\NormalTok{ is converted to a number}\KeywordTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Comparison between
Types}}{Comparison between Types}}\label{comparison-between-types}
\addcontentsline{toc}{subparagraph}{\textbf{Comparison between Types}}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Comparison: Strongly-Typed vs.~Weakly-Typed}\vspace{3mm}

\begin{itemize}
\tightlist
\item
  \textbf{Type Safety:} Strongly-typed languages provide more safety by
  enforcing type rules, reducing errors due to unintended type
  conversions. Weakly-typed languages sacrifice some of this safety for
  flexibility.
\item
  \textbf{Flexibility:} Weakly-typed languages allow for more flexible
  and often shorter code, especially in cases where automatic type
  conversion is beneficial.
\item
  \textbf{Error Handling:} Strongly-typed languages catch type-related
  errors early, often at compile time, while weakly-typed languages may
  only reveal such errors at runtime, if at all.
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection*{Assignment operators}\label{assignment-operators}
\addcontentsline{toc}{subsubsection}{Assignment operators}

\begin{itemize}
\tightlist
\item
  \textbf{Simple Assignment (}\texttt{=}\textbf{):} Assigns a value to a
  variable.
\item
  \textbf{Compound Assignment:}

  \begin{itemize}
  \tightlist
  \item
    \texttt{+=}: Addition
  \item
    \texttt{-=}: Subtraction
  \item
    \texttt{*=}: Multiplication
  \item
    \texttt{/=}: Division
  \item
    \texttt{//=}: Floor Division
  \item
    \texttt{\%=}: Modulus
  \item
    \texttt{**=}: Exponentiation
  \item
    \textbf{Bitwise Operators:} \texttt{\&=}, \texttt{\textbar{}=},
    \texttt{\^{}=}, \texttt{\textless{}\textless{}=},
    \texttt{\textgreater{}\textgreater{}=}
  \end{itemize}
\end{itemize}

Assignment operators streamline code by combining operations and
assignments into a single step, making code more concise and often more
readable.

\paragraph*{Order of operations / precedence
rules}\label{order-of-operations-precedence-rules}
\addcontentsline{toc}{paragraph}{Order of operations / precedence rules}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Operations \& Rules}\vspace{3mm}

\subparagraph*{1. Arithmetic Operations}\label{arithmetic-operations}
\addcontentsline{toc}{subparagraph}{1. Arithmetic Operations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Parentheses:} \texttt{()} - Expressions inside parentheses are
  evaluated first. - Example: \(\text{(2 + 3) * 4}\) evaluates to
  \texttt{20}.
\item
  \textbf{Exponentiation:} ** (or \^{} in some languages like Excel) -
  Raises a number to the power of another number. - Example:
  \(\text{2 ** 3}\) evaluates to \texttt{8}.
\item
  \textbf{Unary Plus and Minus:} \texttt{+}, \texttt{-} \emph{(unary)} -
  Unary plus and minus are applied next. - Example: \(\text{-5 + 3}\)
  evaluates to \texttt{-2}.
\item
  \textbf{Multiplication and Division:} \texttt{*}, \texttt{/},
  \texttt{//} \emph{(floor division)}, \texttt{\%} \emph{(modulus)} -
  Multiplication and division have the same precedence, evaluated from
  left to right. - Example: \(\text{6 / 2 * 3}\) evaluates to
  \texttt{9}.
\item
  \textbf{Addition and Subtraction:} \texttt{+}, \texttt{-} - Addition
  and subtraction have the same precedence, evaluated from left to
  right. - Example: \(\text{5 + 3 - 2}\) evaluates to \texttt{6}.
\end{enumerate}

\subparagraph*{2. Comparison Operations}\label{comparison-operations}
\addcontentsline{toc}{subparagraph}{2. Comparison Operations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Equality and Inequality:} \(==\), \(!=\) - Checks if two
  values are equal or not equal.
\item
  \textbf{Relational Operators:} \(>\), \(<\), \(>=\), \(<=\) - Compares
  two values to determine the relationship between them.
\end{enumerate}

\subparagraph*{3. Logical Operations}\label{logical-operations}
\addcontentsline{toc}{subparagraph}{3. Logical Operations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Negation:} \texttt{not} - Evaluates to the opposite Boolean
  value.
\item
  \textbf{And:} \texttt{and} - Evaluates to \texttt{True} if both
  operands are \texttt{True}.
\item
  \textbf{Or:} \texttt{or} - Evaluates to \texttt{True} if at least one
  operand is \texttt{True}.
\end{enumerate}

\subparagraph*{4. Assignment Operators}\label{assignment-operators-1}
\addcontentsline{toc}{subparagraph}{4. Assignment Operators}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Simple Assignment:} \(=\) - Assigns a value to a variable.
\item
  \textbf{Compound Assignment:} \(+=\), \(-=\), \(*=\), \(/=\), etc. -
  Performs an operation and assigns the result to a variable.
\end{enumerate}

\subparagraph*{5. Bitwise Operations}\label{bitwise-operations}
\addcontentsline{toc}{subparagraph}{5. Bitwise Operations}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Bitwise Not:} \(\text{~}\) - Inverts all bits of the operand.
\item
  \textbf{Bitwise And:} \(\text{&}\) - Performs a bitwise AND operation.
\item
  \textbf{Bitwise Or:} \(|\) - Performs a bitwise OR operation.
\item
  \textbf{Bitwise XOR:} \(\text{^}\) - Performs a bitwise XOR operation.
\item
  \textbf{Bitwise Shift:} \(<<\), \(>>\) - Shifts bits to the left or
  right.
\end{enumerate}

\subparagraph*{6. Miscellaneous}\label{miscellaneous}
\addcontentsline{toc}{subparagraph}{6. Miscellaneous}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Function Calls} - Functions are evaluated first, from
  innermost to outermost.
\item
  \textbf{Member Access:} \(.\) \emph{(dot operator)} - Accesses
  properties or methods of an object.
\item
  \textbf{Indexing and Slicing:} \(\text{[ ]}\) - Retrieves or modifies
  elements from collections like lists or arrays.
\end{enumerate}

\end{tcolorbox}

\paragraph*{Loops}\label{loops}
\addcontentsline{toc}{paragraph}{Loops}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Types of Loops}\vspace{3mm}

\subparagraph*{Topic}\label{topic}
\addcontentsline{toc}{subparagraph}{Topic}

\textbf{For Loop}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} The for loop iterates over a sequence
  \emph{(such as a list, tuple, or string)} or a range of numbers,
  executing a block of code for each item.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Iterating over a list}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ number }\KeywordTok{in}\NormalTok{ numbers:}
    \BuiltInTok{print}\NormalTok{(number)}

\CommentTok{\# Iterating over a range}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\textbf{While Loop}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} The while loop repeatedly executes a block of
  code as long as a specified condition remains True.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Looping while a condition is True}
\NormalTok{count }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ count }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(count)}
\NormalTok{    count }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\textbf{Do-While Loop}

\begin{itemize}
\tightlist
\item
  Description: The \texttt{do-while} loop \emph{(available in C/C++ but
  not in Python)} executes a block of code at least once and then
  repeatedly executes it as long as a condition remains \texttt{True}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Looping at least once and then while a condition is True}
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{    std}\OperatorTok{::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ count }\OperatorTok{\textless{}\textless{}}\NormalTok{ std}\OperatorTok{::}\NormalTok{endl}\OperatorTok{;}
\NormalTok{    count}\OperatorTok{++;}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{count }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Break}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} Exits the loop immediately, regardless of the
  loop's condition.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{5}\NormalTok{:}
        \ControlFlowTok{break}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\textbf{Continue}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} Skips the rest of the code inside the current
  iteration of the loop and proceeds to the next iteration.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{continue}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\textbf{Pass}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} In Python, pass is a placeholder statement used
  when a statement is syntactically required but you do not want to
  execute any code.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{pass}  \CommentTok{\# Do nothing}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\textbf{Nested Loops}

\begin{itemize}
\tightlist
\item
  \textbf{Description:} You can nest loops inside other loops to perform
  more complex iterations.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{):}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"i=}\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\SpecialStringTok{, j=}\SpecialCharTok{\{}\NormalTok{j}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\paragraph*{Conditional statements /
branching}\label{conditional-statements-branching}
\addcontentsline{toc}{paragraph}{Conditional statements / branching}

\begin{tcolorbox}[enhanced jigsaw, colframe=quarto-callout-note-color-frame, toprule=.15mm, bottomrule=.15mm, rightrule=.15mm, colback=white, breakable, arc=.35mm, opacityback=0, left=2mm, leftrule=.75mm]

\vspace{-3mm}\textbf{Types of Statements}\vspace{3mm}

\subparagraph*{Topic}\label{topic-1}
\addcontentsline{toc}{subparagraph}{Topic}

\begin{itemize}
\item
  \textbf{If Statement}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The \texttt{if} statement executes a block of
    code if its condition is \texttt{True}.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{10}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is greater than 5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \textbf{If-Else Statement}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The \texttt{if-else} statement executes one
    block of code if the condition is \texttt{True}, and another block
    if it is \texttt{False}.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is greater than 5"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is 5 or less"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
x is 5 or less
\end{verbatim}

\begin{itemize}
\item
  \textbf{If-Elif-Else Statement}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The \texttt{if-elif-else} statement allows for
    multiple conditions to be checked in sequence. If the if condition
    is \texttt{False}, it checks \texttt{elif} \emph{(else if)}
    conditions in order, and finally executes the \texttt{else} block if
    none of the conditions are \texttt{True}.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{7}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is greater than 10"}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{==} \DecValTok{7}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is 7"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"x is less than 10 and not 7"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \textbf{Switch-Case Statement}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Description:} The \texttt{switch-case} statement \emph{(used
    in C/C++ and some other languages but not Python)} provides a way to
    dispatch execution to different parts of code based on the value of
    an expression.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ day }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{day}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{        std}\OperatorTok{::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Monday"} \OperatorTok{\textless{}\textless{}}\NormalTok{ std}\OperatorTok{::}\NormalTok{endl}\OperatorTok{;}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}
\NormalTok{        std}\OperatorTok{::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Tuesday"} \OperatorTok{\textless{}\textless{}}\NormalTok{ std}\OperatorTok{::}\NormalTok{endl}\OperatorTok{;}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}
\NormalTok{        std}\OperatorTok{::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Wednesday"} \OperatorTok{\textless{}\textless{}}\NormalTok{ std}\OperatorTok{::}\NormalTok{endl}\OperatorTok{;}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{        std}\OperatorTok{::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Other day"} \OperatorTok{\textless{}\textless{}}\NormalTok{ std}\OperatorTok{::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \textbf{AND Operator}

  \begin{itemize}
  \item
    \textbf{Description:} Returns \texttt{True} if both conditions are
    \texttt{True}.
  \item
    \textbf{Syntax:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python/C/C++:} \texttt{condition1\ and\ condition2}
    \end{itemize}
  \item
    \textbf{Example:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python:}
      \texttt{if\ x\ \textgreater{}\ 0\ and\ x\ \textless{}\ 10}
      \textbf{:}
    \item
      \textbf{C++:}
      \texttt{if\ (x\ \textgreater{}\ 0\ \&\&\ x\ \textless{}\ 10)}
    \end{itemize}
  \end{itemize}
\item
  \textbf{OR Operator}

  \begin{itemize}
  \item
    \textbf{Description:} Returns \texttt{True} if at least one of the
    conditions is \texttt{True}.
  \item
    \textbf{Syntax:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python/C/C++:} \texttt{condition1} or \texttt{condition2}
    \end{itemize}
  \item
    \textbf{Example:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python:}
      \texttt{if\ x\ \textless{}\ 0\ or\ x\ \textgreater{}\ 10}
      \textbf{:}
    \item
      \textbf{C++:}
      \texttt{if\ (x\ \textless{}\ 0\ \textbar{}\textbar{}\ x\ \textgreater{}\ 10)}
    \end{itemize}
  \end{itemize}
\item
  \textbf{NOT Operator}

  \begin{itemize}
  \item
    \textbf{Description:} Returns the opposite Boolean value of the
    condition.
  \item
    \textbf{Syntax:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python/C/C++:} \texttt{not\ condition}
    \end{itemize}
  \item
    \textbf{Example:}

    \begin{itemize}
    \tightlist
    \item
      \textbf{Python:} \texttt{if\ not\ x\ \textgreater{}\ 5} \textbf{:}
    \item
      \textbf{C++:} \texttt{if\ (!(x\ \textgreater{}\ 5))}
    \end{itemize}
  \end{itemize}
\end{itemize}

\end{tcolorbox}

\paragraph*{Classes}\label{classes}
\addcontentsline{toc}{paragraph}{Classes}

\textbf{Definition}

A class is essentially a template for creating objects. It encapsulates
data for the object and methods to operate on that data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ ClassName:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, attribute1, attribute2):}
        \VariableTok{self}\NormalTok{.attribute1 }\OperatorTok{=}\NormalTok{ attribute1}
        \VariableTok{self}\NormalTok{.attribute2 }\OperatorTok{=}\NormalTok{ attribute2}

    \KeywordTok{def}\NormalTok{ method\_name(}\VariableTok{self}\NormalTok{):}
        \CommentTok{\# Method code}
\end{Highlighting}
\end{Shaded}

\paragraph*{Components of a Class}\label{components-of-a-class}
\addcontentsline{toc}{paragraph}{Components of a Class}

\section{1. Attributes:}

Variables that hold data related to the class. They define the state of
an object.

\begin{itemize}
\tightlist
\item
  \textbf{Python:} Defined within the \texttt{\_\_init\_\_} method using
  \texttt{self}.
\item
  \textbf{C++:} Defined within the class, often with private access and
  initialized via a constructor.
\end{itemize}

\section{2. Methods:}

Functions defined within a class that operate on its attributes or
perform actions.

\begin{itemize}
\tightlist
\item
  \textbf{Python:} Defined with def keyword within the class.
\item
  \textbf{C++:} Defined with the function signature inside the class and
  implemented outside the class body.
\end{itemize}

\section{3. Constructor:}

A special method that initializes objects of the class. It is called
when an object is created.

\begin{itemize}
\tightlist
\item
  \textbf{Python:} \texttt{\_\_init\_\_} method.
\item
  \textbf{C++:} Defined with the class name and no return type.
\end{itemize}

\section{4. Destructor:}

A method that cleans up when an object is destroyed (in C++). Python
manages memory automatically, so a destructor is less commonly used.

\begin{itemize}
\tightlist
\item
  \textbf{Python:} \texttt{\_\_del\_\_} method \emph{(optional)}.
\item
  \textbf{C++:} Destructor defined with
  \texttt{\textasciitilde{}ClassName()}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Car:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, make, model, year):}
        \VariableTok{self}\NormalTok{.make }\OperatorTok{=}\NormalTok{ make}
        \VariableTok{self}\NormalTok{.model }\OperatorTok{=}\NormalTok{ model}
        \VariableTok{self}\NormalTok{.year }\OperatorTok{=}\NormalTok{ year}

    \KeywordTok{def}\NormalTok{ display\_info(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{year}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{make}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{model}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Creating an object of the class}
\NormalTok{my\_car }\OperatorTok{=}\NormalTok{ Car(}\StringTok{"Toyota"}\NormalTok{, }\StringTok{"Corolla"}\NormalTok{, }\DecValTok{2022}\NormalTok{)}
\NormalTok{my\_car.display\_info()  }\CommentTok{\# Output: 2022 Toyota Corolla}
\end{Highlighting}
\end{Shaded}

\paragraph*{Inheritance}\label{inheritance}
\addcontentsline{toc}{paragraph}{Inheritance}

\section{Definition:}

Inheritance allows you to create a new class that is based on an
existing class, inheriting its attributes and methods.

\section{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ ParentClass:}
    \CommentTok{\# Parent class code}

\KeywordTok{class}\NormalTok{ ChildClass(ParentClass):}
    \CommentTok{\# Child class code}
\end{Highlighting}
\end{Shaded}

\paragraph*{Encapsulation}\label{encapsulation}
\addcontentsline{toc}{paragraph}{Encapsulation}

\section{Definition:}

Encapsulation is the concept of restricting access to certain details of
an object's implementation. It involves using access specifiers to
control the visibility of attributes and methods.

\section{Access Specifiers:}

\begin{itemize}
\item
  \textbf{Python:} Uses naming conventions \emph{(e.g.,
  \texttt{\_private} or \texttt{\_\_private})} rather than strict access
  specifiers.
\item
  \textbf{C++:} Uses \texttt{public}, \texttt{protected}, and
  \texttt{private} keywords to control access.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ BankAccount: }
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, balance):}
  \VariableTok{self}\NormalTok{.\_\_balance }\OperatorTok{=}\NormalTok{ balance}

  \KeywordTok{def}\NormalTok{ deposit(}\VariableTok{self}\NormalTok{, amount):}
      \ControlFlowTok{if}\NormalTok{ amount }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
          \VariableTok{self}\NormalTok{.\_\_balance }\OperatorTok{+=}\NormalTok{ amount}

  \KeywordTok{def}\NormalTok{ get\_balance(}\VariableTok{self}\NormalTok{):}
      \ControlFlowTok{return} \VariableTok{self}\NormalTok{.\_\_balance}

\CommentTok{\# Creating an object of the class}
\NormalTok{account }\OperatorTok{=}\NormalTok{ BankAccount(}\DecValTok{1000}\NormalTok{)}
\NormalTok{account.deposit(}\DecValTok{500}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(account.get\_balance())  }\CommentTok{\# Output: 1500}
\end{Highlighting}
\end{Shaded}

\paragraph*{Polymorphism}\label{polymorphism}
\addcontentsline{toc}{paragraph}{Polymorphism}

\section{Definition:}

Polymorphism allows objects of different classes to be treated as
objects of a common base class, typically through method overriding.

\section{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Animal:}
    \KeywordTok{def}\NormalTok{ speak(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Animal speaks"}\NormalTok{)}

\KeywordTok{class}\NormalTok{ Dog(Animal):}
    \KeywordTok{def}\NormalTok{ speak(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Dog barks"}\NormalTok{)}

\KeywordTok{def}\NormalTok{ make\_animal\_speak(animal):}
\NormalTok{    animal.speak()}

\CommentTok{\# Creating objects}
\NormalTok{animal }\OperatorTok{=}\NormalTok{ Animal()}
\NormalTok{dog }\OperatorTok{=}\NormalTok{ Dog()}

\NormalTok{make\_animal\_speak(animal)  }\CommentTok{\# Output: Animal speaks}
\NormalTok{make\_animal\_speak(dog)     }\CommentTok{\# Output: Dog barks}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subparagraph*{\texorpdfstring{\textbf{Summary}}{Summary}}\label{summary-2}
\addcontentsline{toc}{subparagraph}{\textbf{Summary}}

\begin{itemize}
\tightlist
\item
  \textbf{Classes:} Define custom data types with attributes and
  methods.
\item
  \textbf{Inheritance:} Create new classes based on existing ones,
  inheriting their properties and methods.
\item
  \textbf{Encapsulation:} Restrict access to certain parts of an
  object's implementation.
\item
  \textbf{Polymorphism:} Allow different classes to be treated as
  objects of a common base class, often through method overriding.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\bookmarksetup{startatroot}

\chapter*{Scripting \& Programming}\label{scripting-programming}
\addcontentsline{toc}{chapter}{Scripting \& Programming}

\markboth{Scripting \& Programming}{Scripting \& Programming}

Scripting \& Programming - Applications (D493)

\subsubsection*{Basic}\label{basic}
\addcontentsline{toc}{subsubsection}{Basic}

{\emph{\#include \textless{} \ldots{} \textgreater{}}} \emph{library
facility}\\
\strut ~~a directive that tells the compiler what library will be used.

\emph{\(\text{std}\)} \emph{standard library}\\
\strut ~~is a namespace

\emph{\(::\)} \emph{scope operator}\\
\strut ~~allows look-ups for objects by their names within a namespace

\emph{\(\text{cout}\)} {[}see ‚Ä¢ out{]} \emph{character out}\\
\strut ~~a standard \(IO\) object

\emph{\(\text{cin}\)} {[}see ‚Ä¢ in{]} \emph{character in}\\
\strut ~~a standard \(IO\) object

\emph{\(\text{endl;}\)} \emph{manipulator}\\
\strut ~~ends the current line and flushes the \emph{buffer} associated
with the device to force the text to show up on the console.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}iostream\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{()}
\OperatorTok{\{}
  \BuiltInTok{std::}\NormalTok{cout }\OperatorTok{\textless{}\textless{}} \StringTok{"Hello, World!"} \OperatorTok{\textless{}\textless{}} \BuiltInTok{std::}\NormalTok{endl}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\chapter*{Big Data}\label{big-data}
\addcontentsline{toc}{chapter}{Big Data}

\markboth{Big Data}{Big Data}

Big Data Foundations (D495)

\emph{coming soon}

\bookmarksetup{startatroot}

\chapter{Summary}\label{summary-3}

In summary, this book has no content whatsoever.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \SpecialCharTok{+} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2
\end{verbatim}

\bookmarksetup{startatroot}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{References}

\phantomsection\label{refs}




\end{document}
